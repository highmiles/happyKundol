dd
 ## const 와 object.freeze()의 차이
 const는 변수의 재할당을 막지만 원시적인 Number, String에 한해서 입니다. 왜냐하면 객체의 경우에는 주소값이 할당되고 이 주소값은 바뀌지 않지만 그 값은 바뀔 수 있기 때문입니다. 따라서 const로 선언을 하면 객체의 값은 수정됩니다.  
 하지만 object.freeze()는 객체의 값이 바뀌는 것을 아예막기 때문에 수정되지 않습니다. 그러나 2단계이상 깊이의 객체면 속성이 변경이 가능합니다. 
 
 ## 호이스팅 
 모든 변수들이 var로 선언될 때 범위가 가장 상단으로 간다. 
 함수 선언도 마찬가지다. 
 함수, 변수 선언이 컴파일 단계에서 메모리에 추가되는 것이다. 
 ```
    a = 3;
    console.log(a);
    var a; 
    //3
    console.log(a);
    var a = 3;
    // undefined
 ```
 자바스크립트는 선언만 호이스팅이 되고 할당, 초기화는 호이스팅이 되지 않는다. 
 앱성능 사이트 : https://app.sessionstack.com/#/signup 

 ## 스코프체인
 변수가 없다면 좀 더 위쪽으로 찾아가는 여행입니다.
 함수를 처음 선언하는 순간, 내부의 변수는 자기 스코프로부터 가장 가까운 곳부터 변수를 계속 참조하게 됩니다. 
 `스코프 : 어떤 변수들에 접근할 수 있는 지를 정의, 함수 & 블록 스코프로 나누어집니다.`
 
 변수의 유효범위는 실행 중에 설정되지 않고, 정의될 때의 함수단위, "렉시컬한 환경"으로 설정이 되며    
 함수가 다른 함수 내부에서 정의되었을 때 내부함수는 외부함수의 변수에 접근 가능하지만
 외부함수는 내부함수의 변수에 접근 불가 
 이를 "렉시컬 스코핑"이라고 합니다.
 ```
 function outerFunction () {
  const outer = 'I’m the outer function!'
    
  function innerFunction() {
     const inner = 'I’m the inner function!'
     console.log(outer) // I’m the outer function!
  }
    
  console.log(inner) // Error, inner is not defined
}
```
여러 레이어의 함수는 여러 레이어로 이루어진 단방향 투과성유리를 생각하면 되듯이 안쪽에서 바깥쪽은 참조가 가능해도 바깥쪽에서 안쪽은 불가능
합니다.

```
function prepareCake (flavor) {
  return function () {
    setTimeout(_ => console.log('Made a ${flavor} cake!', 1000))
  }
}
const makeCakeLater = prepareCake(‘banana’)
// And later in your code…
makeCakeLater()
// Made a banana cake!
```  

이렇게 클로저를 이용하면 렉시컬 환경이 끝나면 GC가 회수해야 하지만 그렇지 않게 만들 수 있습니다. 
함수로 래핑하여 flavor이라는 인자를 참조하여 쓸 수 있습니다.

## 호이스팅
```
var arr = [1, 2, 3, 4]
function a(){
    function b(val){
        i = 10
        console.log(i)
        return val * i
    }
    for(var i = 0; i < arr.length; i++){
        arr[i] = b(arr[i])
    }
    return arr; 
}
console.log(a())
//10
//[ 10, 2, 3, 4 ]
```
반복문 안의 루프 카운터 i가 호이스팅이 되어 내부함수 b의 클로저에 포함이 됩니다. 이 때 i를 변경해서 루프카운터까지 변경되게 되어서
꼬이게 됩니다. 
