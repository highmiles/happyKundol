 # JS

 ## const 와 object.freeze()의 차이
 const는 변수의 재할당을 막지만 원시적인 Number, String에 한해서 입니다. 왜냐하면 객체의 경우에는 주소값이 할당되고 이 주소값은 바뀌지 않지만 그 값은 바뀔 수 있기 때문입니다. 따라서 const로 선언을 하면 객체의 값은 수정됩니다.  
 하지만 object.freeze()는 객체의 값이 바뀌는 것을 아예막기 때문에 수정되지 않습니다. 그러나 2단계이상 깊이의 객체면 속성이 변경이 가능합니다. 

 ## 호이스팅 
 모든 변수들이 var로 선언될 때 범위가 가장 상단으로 간다. 
 함수 선언도 마찬가지다. 
 함수, 변수 선언이 컴파일 단계에서 메모리에 추가되는 것이다. 
 ```
    a = 3;
    console.log(a);
    var a; 
    //3
    console.log(a);
    var a = 3;
    // undefined
 ```
 자바스크립트는 선언만 호이스팅이 되고 할당, 초기화는 호이스팅이 되지 않는다.  
```
var arr = [1, 2, 3, 4]
function a(){
    function b(val){
        i = 10
        console.log(i)
        return val * i
    }
    for(var i = 0; i < arr.length; i++){
        arr[i] = b(arr[i])
    }
    return arr; 
}
console.log(a())
//10
//[ 10, 2, 3, 4 ]
```
반복문 안의 루프 카운터 i가 호이스팅이 되어 내부함수 b의 클로저에 포함이 됩니다. 이 때 i를 변경해서 루프카운터까지 변경되게 되어서
꼬이게 됩니다. 

 ## 스코프체인
 변수가 없다면 좀 더 위쪽으로 찾아가는 여행입니다.
 함수를 처음 선언하는 순간, 내부의 변수는 자기 스코프로부터 가장 가까운 곳부터 변수를 계속 참조하게 됩니다. 
 `스코프 : 어떤 변수들에 접근할 수 있는 지를 정의, 함수 & 블록 스코프로 나누어집니다.`
 변수의 유효범위는 실행 중에 설정되지 않고, 정의 및 초기화될 때의 함수단위, "렉시컬한 환경"으로 설정이 되며    
 함수가 다른 함수 내부에서 정의되었을 때 내부함수는 외부함수의 변수에 접근 가능하지만
 외부함수는 내부함수의 변수에 접근 불가 
 이를 "렉시컬 스코핑"이라고 합니다.
 ```
 function outerFunction () {
  const outer = 'I’m the outer function!'
    
  function innerFunction() {
     const inner = 'I’m the inner function!'
     console.log(outer) // I’m the outer function!
  }
    
  console.log(inner) // Error, inner is not defined
}
```
여러 레이어의 함수는 여러 레이어로 이루어진 단방향 투과성유리를 생각하면 되듯이 안쪽에서 바깥쪽은 참조가 가능해도 바깥쪽에서 안쪽은 불가능
합니다.

```
function prepareCake (flavor) {
  return function () {
    setTimeout(_ => console.log('Made a ${flavor} cake!', 1000))
  }
}
const makeCakeLater = prepareCake(‘banana’)
// And later in your code…
makeCakeLater()
// Made a banana cake!
```  

이렇게 클로저를 이용하면 렉시컬 환경이 끝나면 GC가 회수해야 하지만 그렇지 않게 만들 수 있습니다. 
함수로 래핑하여 flavor이라는 인자를 참조하여 쓸 수 있습니다.

### 렉시컬 환경
렉시컬(lexical)은 영문으로 "단위, 어휘와 관련 있다"라는 의미를 지닙니다.

 javascript에서는 렉시컬 특성을 프로그램 "코드"와 관련있다고 생각할 수 있습니다. 

즉, 함수를 실행 단계가 아닌 정의단계에서 유효범위를 설정하고 있습니다.

이는 변수의 유효범위는 실행 중에 설정되는 것이 아닌, 정의될때의 함수 단위로 설정이 되기 때문입니다.

lexical scoping이라고 합니다. 한글로는 어떻게 번역해야 할지 모르겠네요. 직역하면 어휘적 범위인데 좀 어색하죠? 정적 스코프가 더 나아 보이네요.

lexical scoping이 좀 이해하기 힘들기 때문에 다시 설명드리겠습니다. 함수를 처음 선언하는 순간, 함수 내부의 변수는 자기 스코프로부터 가장 가까운 곳(상위 범위에서)에 있는 변수를 계속 참조하게 됩니다. 위의 예시에서는 log 함수 안의 name 변수는 선언 시 가장 가까운 전역변수 name을 참조하게 됩니다. 그래서 wrapper 안에서 log를 호출해도 지역변수 name='nero'를 참조하는 게 아니라 그대로 전역변수 name의 값인 zero가 나오는 겁니다.

무슨 짓을 해도 log 함수가 한 번 선언된 이상, 전역변수를 가리키게 되어있는 name 변수가 다른 걸 가리키게 할 수 없습니다. 유일한 방법은 아까처럼 전역변수를 다른 값으로 바꾸는 겁니다. 다음 시간에 실행 컨텍스트에 대해서 배울텐데 그 때 정확한 원리를 설명드리겠습니다.

### 자바스크립트 최적화기법
for-in 루프가 느린이유
인스턴스, 프로토타입 체인을 검색해야 하므로 느립니다. 

복잡한 정규표현식을 간단하게 
패턴하나로 모든 일을 처리하는 괴물같은 정규표현식은 관리하기 어렵고 역추적관련 문제를 일으킵니다. 
역추적: 정규표현식 엔진 대부분에서 근간이 되는 구성요소. 정규표현식은 정규표현식과 일치하는 게 없다면 정규표현식은 시도해보지 않은 옵션이 있는 마지막 지점까지 역추적해서 다른 옵션을 선택한다.

POST와  GET
단지 데이터를 요청할 뿐이라면(이러한 요청을 멱등 액션이라 한다) GET을,
(GET요청은 캐시되기 때문에 같은 데이터를 여러번 가져올 때 성능은 향상된다.)
POST 요청은 URL과 매개변수 길이가 2048글자를 넘거나 그에 근접할 때만 써야 한다. 
인터넷 익스플로러는 URL길이를 2048글자로 제한하며 요청문자열에서 이를 넘기는 부분은 잘리기 때문이다. 

eval()은 넘나 위험한 것
eval()함수는 악의적이거나 잘못 만들어진 코드를 포함할 가능성 농후, 
JSON.parse()를 사용하자. 

비트연산자를 잘활용하자 

### 의존성 역전원칙
클래스 A가 클래스 B의 서비스가 필요할 때  A는 B를 생성하지 않는다. 대신 A 생성자에 건넨 파라미터 하나가 B를 서술하는 인터페이스 역할을 한다. 이제 A는 B에 의존하지 않고 자신의 인터페이스만 바라본다. A가 생성되면 구체화한 B를 넘겨받는다. B 역시 인터페이스에 의존한다. 
```
d3.svg.line = function(){
 return d3_svg_line(d3_identity);
};
function d3_svg_line(projection){
 function segment(){
  segments.push("M",interpolate(projection(points),tension));
 }
}
```
여기서 projection은 점 데이터를 다른 좌표 공간에 투사할 때를 대비한 파라미터이다. projection 기본값은 d3_indentity로 점 데이터를 변경하지는 않지만, 다른 방법으로 투사할 수는 있다. 
예컨대, d3_svg_lineRadial 투사를 주입하면, d3.svg.line.radial로 극 좌표계를 사용할 수 있다. 
```
d3.svg.line.radial = function(){
 var line = d3_svg_line(d3_svg_lineRadial);
 return line;
};
function d3_svg_lineRadial(points){
 return points;
}
```


# HTML5 & CSS
### CSS최적화 
1. 불필요한 DOM 제거
2. 간략하게 할 수 있다면 간략하게..!
3. CSS파일의 크기를 줄이는 것
 px을 없애고 shorthand를 사용하자
CSS SPRITE이미지를 쓰자 
### http2설명필요
하위 선택자는 좀 더 깔끔하게
repaint 와 reflow를 최소화



# Web
## RESTful API  
## GC
## 브라우저의 렌더링 과정
https://d2.naver.com/helloworld/59361 
## OOP
상속, 캡슐화, 설계과정, 예제 
## 함수형 프로그래밍(Function Programming) 
https://jhc9639.blog.me/221486916086?Redirect=Log&from=postView
재포스팅
## 폰트과정
크롬, 사파리, 익스플로러 : 새로운 폰트 로딩되기전 blank space 현상
파이어폭스 : 기본폰트로 일단 로딩
#### 지금의 기준 다시 확인 필요 

#### Lazy 로딩
이미지, 스크립트, CSS 파일들이 lazy 로드 되어서 현 페이지의 응답시간을 향상시킴 (각 섹션의 자세한 부분을 참조하시오).

#### SEO
구글 애널리틱스 체커
적절한 제목 배치 
sitemap.xml
robots.txt 파일이 웹페이지를 블록킹 하지 않음
Google Robots 테스트 도구를 이용하여 당신의 robots.txt 파일을 테스트 해보세요
RDFa - Linked Data in HTML
구조화 된 데이터 테스트 도구를 이용하여 당신의 페이지를 테스트 해보세요
어떤 것들? 
구조화 된 데이터로 사용될 수 있는 단어들의 목록을 만들어보세요 Schema.org Full Heirarchy
HTML 사이트맵: Medium HTML 사이트맵이 제공되었으며 웹사이트의 푸터 내에 존재하는 링크를 통하여 접근이 가능함
사이트맵 가이드라인 - Google Support
Pagination link tags: Medium Provide rel="prev" and rel="next" to indicate paginated content.
Pagination guidelines - Google Support 
### Ajax
Ajax (asynchronous JavaScript and XML)는 비동기 웹 응용 프로그램을 만들기 위해 클라이언트 측에서 여러 웹 기술을 사용하는 웹 개발 기술의 집합입니다. Ajax를 사용하면 웹 애플리케이션은 기존 페이지의 화면 및 동작을 방해하지 않으면서 백그라운드에서 비동기적으로 서버로 데이터를 보내고 서버에서 데이터를 받아올 수 있습니다. Ajax는 프리젠테이션 레이어에서 데이터 교환 레이어를 분리함으로써 웹 페이지 및 확장 웹 애플리케이션이 전체 페이지를 다시 로드 할 필요 없이 동적으로 컨텐츠를 변경할 수 있도록 합니다. 실제로 최근에는 일반적으로 네이티브 JavaScript의 장점 때문에 XML 대신 JSON을 사용합니다. 
`XMLHttpRequest` API는 비동기 통신 또는 최근 `fetch` API에 자주 사용됩니다. 
### Ajax를 사용하는 것의 장단점은 무엇입니까?

**장점**

* 상호작용성이 좋아집니다. 서버의 새로운 컨텐츠를 전체 페이지를 다시로드 할 필요 없이 동적으로 변경할 수 있습니다.
* 스크립트 및 스타일 시트는 한 번만 요청하면 되므로 서버에 대한 연결을 줄여줍니다.
* 상태를 페이지에서 관리 할 수 ​​있습니다. 메인 컨테이너 페이지가 다시 로드되지 않기 때문에 JavaScript의 변수와 DOM의 상태가 유지됩니다.
* 기본적으로 SPA의 장점 대부분입니다.
https://poiemaweb.com/js-spa

**단점**

* 동적 웹 페이지는 북마크 하기 어렵습니다.
* 브라우저에서 JavaScript가 비활성화된 경우 작동하지 않습니다.
* 일부 웹 크롤러는 JavaScript를 실행하지 않으며 JavaScript에 의해 로드된 콘텐츠를 볼 수 없습니다.
* SPA의 대부분의 단점이 대부분입니다.
### Promise와 callback
### CPS ? 

Continuation Passing Style Patterns

Promise의 코드 구성 
https://poiemaweb.com/es6-promise

Promise와 Callback의 차이점은 무엇이며 각각의 장단점
Callback Hell은 코드의 가독성을 나쁘게 하고 복잡도를 증가시켜 실수를 유발하는 원인이 되며 에러 처리가 곤란하다. 
Promise는 어느 시점에 resolve된 값 또는 resolve되지 않은 이유(예: 네트워크 오류가 발생) 중 하나의 값을 생성할 수 있는 객체입니다. promise는 fulfilled, rejected, pending 3가지 상태 중 하나일 수 있습니다. promise 사용자는 콜백을 붙여서 fulfill된 값이나 reject된 이유를 처리할 수 ​​있습니다.

**장점**

* 이해하기 어려운 콜백 지옥을 피할 수 있습니다.
* 읽기 쉬운 `.then()`을 이용하여 연속적인 비동기 코드를 쉽게 작성할 수 있습니다.
* `Promise.all()`을 사용하여 병렬 비동기 코드를 쉽게 작성할 수 있습니다.

**단점**

* 약간 더 복잡한 소스코드(논쟁의 여지가 있음)
* ES2015를 지원하지 않는 이전 브라우저에서 이를 사용하기 위해서는 polyfill을 로드해야 합니다.

#### 가상좀Vue.js
면접관을 Vue.js 비사용자라고 가정하고 Vue.js에 설명하고 장단점을 말해달라
Vue.js의 Life-cycle에 대해 아는대로 말해달라
Vue.js 에서 DOM은 어느 시점에 생성되나
Computed와 Methods의 차이점은 무엇인가
가상돔(Virtual DOM) 개념은 무엇이며, DOM과의 차이점 가상돔의 개념이 사용되게된 배경은 무엇인가
최근의 프레임워크를 사용할때 외부 라이브러리와의 결합시에 더 나은 코드 작성법을 고민해본적이 있는가
DOM을 직접 조작하는 D3.js 같은 라이브러리와의 결합시에 예상되는 문제점이 있는가

#### AMP
AMP의 개념은 무엇이고 기존의 것에 비해 장점은 무엇인가
최근의 프레임워크들과의 조합을 고려해 본적이 있는가 ex) vue-amp..
타입스크립트를 사용해본 경험이 있는가, 타입스크립트에 대한 본인의 생각과 도입시의 장점을 말해달라

#### 자바스크립트의 원시 타입(Primitive Data Type)은 몇가지이며, 전부 말해달라
Number, String, Boolean, Null, Undefined, (Symbol)
자바스크립트의 Number Type은 다른 언어들과 차이점이 무엇인가, 왜 하나만 존재하는가
숫자
자바스크립트는 다른 프로그래밍 언어와 마찬가지로 실제 숫자의 근사치를 저장할 때 IEEE-764 배정도 부동소수점 숫자형식을 사용합니다. 이 형식을 더블 이라고 부를 겁니다. 0.1 + 0.2 를 하면 0.300000000000004를 반환하는데 이는 무한한 값을 유한한 메모리 안에서 가능한 한 정확히 짐작하려다 생긴 결과입니다. 자바스크립트에는 숫자형 데이터 타입이 하나밖에 없는데, 이건 흔치 않은 일입니다. 대부분의 프로그래밍 언어는 여러 가지 정수 타입을 사용하며 부동소수점 숫자 타입도 두가지 이상을 사용합니다. 숫자형 데이터를 하나만 갖기로 한 선택은 자바스크립트를 단순한 언어로, 특히 초보자에게 부담없는 언어로 만들었다는 장점이 있습니다. 반면 자바스크립트를 고성능 정수연산이나 정밀한 소수점 연산이 필요한 애플리케이션에서 쓸 수 없게 만든 선택이기도 합니다. 
*자바스크립트는 64비트 부동소수점을 가진다. 4를 16진수로 표현하려면? 4.toString(16)으로 하면 된다. 



#### 실행 컨텍스트(Execution Context)
#1. 실행 컨텍스트
실행 컨텍스트(Execution Context)는 scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다. 실행 컨텍스트를 바로 이해하지 못하면 코드 독해가 어려워지며 디버깅도 매우 곤란해 질 것이다.

ECMAScript 스펙에 따르면 실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의한다. 좀 더 쉽게 말하자면 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경 이라고 말할 수 있겠다. 여기서 말하는 실행 가능한 코드는 아래와 같다.

전역 코드 : 전역 영역에 존재하는 코드
Eval 코드 : eval 함수로 실행되는 코드
함수 코드 : 함수 내에 존재하는 코드
일반적으로 실행 가능한 코드는 전역 코드와 함수 내 코드이다.

자바스크립트 엔진은 코드를 실행하기 위하여 실행에 필요한 여러가지 정보를 알고 있어야 한다. 실행에 필요한 여러가지 정보란 아래와 같은 것들이 있다.

변수 : 전역변수, 지역변수, 매개변수, 객체의 프로퍼티
함수 선언
변수의 유효범위(Scope)
this
이와 같이 실행에 필요한 정보를 형상화하고 구분하기 위해 자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다. 아래의 코드를 살펴보자.
```
var x = 'xxx';

function foo () {
  var y = 'yyy';

  function bar () {
    var z = 'zzz';
    console.log(x + y + z);
  }
  bar();
}
foo();
```
위 코드를 실행하면 아래와 같이 실행 컨텍스트 스택(Stack)이 생성하고 소멸한다. 현재 실행 중인 컨텍스트에서 이 컨텍스트와 관련없는 코드(예를 들어 다른 함수)가 실행되면 새로운 컨텍스트가 생성된다. 이 컨텍스트는 스택에 쌓이게 되고 컨트롤(제어권)이 이동한다.



![논리적 스택 구조를 가지는 실행 컨텍스트택](https://poiemaweb.com/img/ec_1.png)

컨트롤이 실행 가능한 코드로 이동하면 논리적 스택 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 스택은 LIFO(Last In First Out, 후입 선출)의 구조를 가지는 나열 구조이다.

전역 코드(Global code)로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다.

함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며 직전에 실행된 코드 블록의 실행 컨텍스트 위에 쌓인다.

함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다.

#2. 실행 컨텍스트의 3가지 객체
실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 가지며 아래의 3가지 프로퍼티를 소유한다.



![실행 컨텍스트의 구조](https://poiemaweb.com/img/excute_context_structure.png)

#2.1 Variable Object (VO / 변수객체)
실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보들을 담을 객체를 생성한다. 이를 Variable Object(VO / 변수 객체)라고 한다. Variable Object는 코드가 실행될 때 엔진에 의해 참조되며 코드에서는 접근할 수 없다.

Variable Object는 아래의 정보를 담는 객체이다.

변수
매개변수(parameter)와 인수 정보(arguments)
함수 선언(함수 표현식은 제외)
Variable Object는 실행 컨텍스트의 프로퍼티이기 때문에 값을 갖는데 이 값은 다른 객체를 가리킨다. 그런데 전역 코드 실행시 생성되는 전역 컨텍스트의 경우와 함수를 실행할 때 생성되는 함수 컨텍스트의 경우, 가리키는 객체가 다르다. 이는 전역 코드와 함수의 내용이 다르기 때문이다. 예를 들어 전역 코드에는 매개변수가 없지만 함수에는 매개변수가 있다.

Variable Object가 가리키는 객체는 아래와 같다.

전역 컨텍스트의 경우
Variable Object는 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Global Object / GO)를 가리킨다. 전역 객체는 전역에 선언된 전역 변수와 전역 함수를 프로퍼티로 소유한다.
ec-vo-global

![전역 컨텍스트의 경우, Variable Object가 가리키는 전역 객체](https://poiemaweb.com/img/ec-vo-global.png)

함수 컨텍스트의 경우
Variable Object는 Activation Object(AO / 활성 객체)를 가리키며 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가된다.
ec-vo-foo

![함수 컨텍스트의 경우, Variable Object가 가리키는 Activation Object](https://poiemaweb.com/img/ec-vo-foo.png)

#2.2 Scope Chain (SC)
스코프 체인(Scope Chain)은 일종의 리스트로서 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있다. 다시 말해, 스코프 체인은 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고 있는 전역 객체(GO) 또는 활성 객체(AO)의 리스트를 가리킨다.

현재 실행 컨텍스트의 활성 객체(AO)를 선두로 하여 순차적으로 상위 컨텍스트의 활성 객체(AO)를 가리키며 마지막 리스트는 전역 객체(GO)를 가리킨다.

![스코프 체인](https://poiemaweb.com/img/ec-sc.png)

스코프 체인은 식별자 중에서 객체(전역 객체 제외)의 프로퍼티가 아닌 식별자, 즉 변수를 검색하는 메커니즘이다.
식별자 중에서 변수가 아닌 객체의 프로퍼티(물론 메소드도 포함된다)를 검색하는 메커니즘은 프로토타입 체인(Prototype Chain)이다.

엔진은 스코프 체인을 통해 렉시컬 스코프를 파악한다. 함수가 중첩 상태일 때 하위함수 내에서 상위함수의 스코프와 전역 스코프까지 참조할 수 있는데 이것는 스코프 체인을 검색을 통해 가능하다. 함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인에 포함된다. 함수 실행중에 변수를 만나면 그 변수를 우선 현재 Scope, 즉 Activation Object에서 검색해보고, 만약 검색에 실패하면 스코프 체인에 담겨진 순서대로 그 검색을 이어가게 되는 것이다. 이것이 스코프 체인이라고 불리는 이유이다.

예를 들어 함수 내의 코드에서 변수를 참조하면 엔진은 스코프 체인의 첫번째 리스트가 가리키는 AO에 접근하여 변수를 검색한다. 만일 검색에 실패하면 다음 리스트가 가리키는 Activation Object(또는 전역 객체)를 검색한다. 이와 같이 순차적으로 스코프 체인에서 변수를 검색하는데 결국 검색에 실패하면 정의되지 않은 변수에 접근하는 것으로 판단하여 Reference 에러를 발생시킨다. 스코프 체인은 함수의 감추인 프로퍼티인 [[Scope]]로 참조할 수 있다.

#2.3 this value
this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.

#3. 실행 컨텍스트의 생성 과정
앞에서 살펴본 아래의 코드를 가지고 실제로 어떻게 실행 컨텍스트가 생성되는지 알아보자.
```
var x = 'xxx';

function foo () {
  var y = 'yyy';

  function bar () {
    var z = 'zzz';
    console.log(x + y + z);
  }
  bar();
}
```


foo();
#3.1 전역 코드에의 진입
컨트롤이 실행 컨텍스트에 진입하기 이전에 유일한 전역 객체(Global Object)가 생성된다. 전역 객체는 단일 사본으로 존재하며 이 객체의 프로퍼티는 코드의 어떠한 곳에서도 접근할 수 있다. 초기 상태의 전역 객체에는 빌트인 객체(Math, String, Array 등)와 BOM, DOM이 설정되어 있다.

![초기 상태의 실행 컨텍스트](https://poiemaweb.com/img/ec_3.png)

초기 상태의 실행 컨텍스트

전역 객체가 생성된 이후, 전역 코드로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다.

![전역 실행 컨텍스트의 생성](https://poiemaweb.com/img/ec_4.png)

전역 실행 컨텍스트의 생성

그리고 이후 이 실행 컨텍스트를 바탕으로 이하의 처리가 실행된다.

스코프 체인의 생성과 초기화
Variable Instantiation(변수 객체화) 실행
this value 결정
#3.1.1 스코프 체인의 생성과 초기화
실행 컨텍스트가 생성된 이후 가장 먼저 스코프 체인의 생성과 초기화가 실행된다. 이때 스코프 체인은 전역 객체의 레퍼런스를 포함하는 리스트가 된다.

스코프 체인의 생성과 초기화

스코프 체인의 생성과 초기화

#3.1.2 Variable Instantiation(변수 객체화) 실행
스코프 체인의 생성과 초기화가 종료하면 변수 객체화(Variable Instantiation)가 실행된다.

Variable Instantiation은 Variable Object에 프로퍼티와 값을 추가하는 것을 의미한다. 변수 객체화라고 번역하기도 하는데 이는 변수, 매개변수와 인수 정보(arguments), 함수 선언을 Variable Object에 추가하여 객체화하기 때문이다.

전역 코드의 경우, Variable Object는 Global Object를 가리킨다.

![Variable Instantiation](https://poiemaweb.com/img/ec_6.png)

Variable Instantiation(변수 객체화): VO와 GO의 연결

Variable Instantiation(변수 객체화)는 아래의 순서로 Variable Object에 프로퍼티와 값을 set한다. (반드시 1→2→3 순서로 실행된다.)

1. (Function Code인 경우) 매개변수(parameter)가 Variable Object의 프로퍼티로, 인수(argument)가 값으로 설정된다.

2. 대상 코드 내의 함수 선언(함수 표현식 제외)을 대상으로 함수명이 Variable Object의 프로퍼티로, 생성된 함수 객체가 값으로 설정된다.(함수 호이스팅)

3. 대상 코드 내의 변수 선언을 대상으로 변수명이 Variable Object의 프로퍼티로, undefined가 값으로 설정된다.(변수 호이스팅)

위 예제 코드를 보면 전역 코드에 변수 x와 함수 foo(매개변수 없음)가 선언되었다. Variable Instantiation의 실행 순서 상, 우선 2. 함수 foo의 선언이 처리되고(함수 코드가 아닌 전역 코드이기 때문에 1. 매개변수 처리는 실행되지 않는다.) 그 후 3. 변수 x의 선언이 처리된다.

#3.1.2.1 함수 foo의 선언 처리
함수 선언은 Variable Instantiation 실행 순서 2.와 같이 선언된 함수명 foo가 Variable Object(전역 코드인 경우 Global Object)의 프로퍼티로, 생성된 함수 객체가 값으로 설정된다.

![함수 foo의 선언 처리](https://poiemaweb.com/img/ec_7.png)

함수 foo의 선언 처리

생성된 함수 객체는 [[Scopes]] 프로퍼티를 가지게 된다. [[Scopes]] 프로퍼티는 함수 객체만이 소유하는 내부 프로퍼티(Internal Property)로서 함수 객체가 실행되는 환경을 가리킨다. 따라서 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정한다. 내부 함수의 [[Scopes]] 프로퍼티는 자신의 실행 환경(Lexical Enviroment)과 자신을 포함하는 외부 함수의 실행 환경과 전역 객체를 가리키는데 이때 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 [[Scopes]] 프로퍼티가 가리키는 외부 함수의 실행 환경(Activation object)은 소멸하지 않고 참조할 수 있다. 이것이 클로저이다.

![함수 foo의 [[Scopes]]](https://poiemaweb.com/img/foo-scopes.png)

함수 foo의 [[Scopes]]

지금까지 살펴본 실행 컨텍스트는 아직 코드가 실행되기 이전이다. 하지만 스코프 체인이 가리키는 변수 객체(VO)에 이미 함수가 등록되어 있으므로 이후 코드를 실행할 때 함수선언식 이전에 함수를 호출할 수 있게 되었다.

이때 알 수 있는 것은 함수선언식의 경우, 변수 객체(VO)에 함수표현식과 동일하게 함수명을 프로퍼티로 함수 객체를 할당한다는 것이다. 단, 함수선언식은 변수 객체(VO)에 함수명을 프로퍼티로 추가하고 즉시 함수 객체를 즉시 할당하지만 함수 표현식은 일반 변수의 방식을 따른다. 따라서 함수선언식의 경우, 선언문 이전에 함수를 호출할 수 있다. 이러한 현상을 함수 호이스팅(Function Hoisting)이라 한다.

#3.1.2.2 변수 x의 선언 처리
변수 선언은 Variable Instantiation 실행 순서 3.과 같이 선언된 변수명( x )이 Variable Object의 프로퍼티로, undefined가 값으로 설정된다. 이것을 좀더 세분화 해보면 아래와 같다.

선언 단계(Declaration phase)
변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조할 수 있는 대상이 된다.

초기화 단계(Initialization phase)
변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.

할당 단계(Assignment phase)
undefined로 초기화된 변수에 실제값을 할당한다.

var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 다시 말해 스코프 체인이 가리키는 변수 객체에 변수가 등록되고 변수는 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라한다.

아직 변수 x는 ‘xxx’로 초기화되지 않았다. 이후 변수 할당문에 도달하면 비로소 값의 할당이 이루어진다.

![변수 x의 선언 처리](https://poiemaweb.com/img/ec_8.png)

변수 x의 선언 처리

#3.1.3 this value 결정
변수 선언 처리가 끝나면 다음은 this value가 결정된다. this value가 결정되기 이전에 this는 전역 객체를 가리키고 있다가 함수 호출 패턴에 의해 this에 할당되는 값이 결정된다. 전역 코드의 경우, this는 전역 객체를 가리킨다.

![this value 결정](https://poiemaweb.com/img/ec_9.png)

this value 결정

전역 컨텍스트(전역 코드)의 경우, Variable Object, 스코프 체인, this 값은 언제나 전역 객체이다.

#3.2. 전역 코드의 실행
지금까지는 코드 실행 환경을 갖추기 위한 사전 준비였다. 코드의 실행은 지금부터 시작된다.
```
var x = 'xxx';

function foo () {
  var y = 'yyy';

  function bar () {
    var z = 'zzz';
    console.log(x + y + z);
  }
  bar();
}
foo();
```
위 예제를 보면 전역 변수 x에 문자열 ‘xxx’ 할당과 함수 foo의 호출이 실행된다.

#3.2.1 변수 값의 할당
전역 변수 x에 문자열 ‘xxx’를 할당할 때, 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 Variable Object를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값(‘xxx’)을 할당한다.

![변수 값의 할당](https://poiemaweb.com/img/ec_10.png)

변수 값의 할당

#3.2.2 함수 foo의 실행
전역 코드의 함수 foo가 실행되기 시작하면 새로운 함수 실행 컨텍스트가 생성된다. 함수 foo의 실행 컨텍스트로 컨트롤이 이동하면 전역 코드의 경우와 마찬가지로 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순차적으로 실행된다.

단, 전역 코드와 다른 점은 이번 실행되는 코드는 함수 코드라는 것이다. 따라서 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정은 전역 코드의 룰이 아닌 함수 코드의 룰이 적용된다.

![함수 foo의 실행 컨텍스트 생성](https://poiemaweb.com/img/ec_11.png)

함수 foo의 실행 컨텍스트 생성

#3.2.2.1 스코프 체인의 생성과 초기화
함수 코드의 스코프 체인의 생성과 초기화는 우선 Activation Object에 대한 레퍼런스를 스코프 체인의 선두에 설정하는 것으로 시작된다.

Activation Object는 우선 arguments 프로퍼티의 초기화를 실행하고 그 후, Variable Instantiation가 실행된다. Activation Object는 스펙 상의 개념으로 프로그램이 Activation Object에 직접 접근할 수 없다. (Activation Object의 프로퍼티로의 접근은 가능하다)

![스코프 체인의 생성과 초기화](https://poiemaweb.com/img/ec_12.png)

스코프 체인의 생성과 초기화: Activation Object의 생성과 바인딩

그 후, Caller(전역 컨텍스트)의 Scope Chain이 참조하고 있는 객체가 스코프 체인에 push된다. 따라서, 이 경우 함수 foo를 실행한 직후 실행 컨텍스트의 스코프 체인은 Activation Object(함수 foo의 실행으로 만들어진 AO-1)과 전역 객체를 순차적으로 참조하게 된다.

![스코프 체인의 생성과 초기화](https://poiemaweb.com/img/ec_13.png)

스코프 체인의 생성과 초기화: Caller의 [[Scope]]를 스코프 체인에 push

#3.2.2.2 Variable Instantiation 실행
Function Code의 경우, 스코프 체인의 생성과 초기화에서 생성된 Activation Object를 Variable Object로서 Variable Instantiation가 실행된다. 이것을 제외하면 전역 코드의 경우와 같은 처리가 실행된다. 즉, 함수 객체를 Variable Object(AO-1)에 바인딩한다. (프로퍼티는 bar, 값은 새로 생성된 Function Object. bar function object의 [[Scope]] 프로퍼티 값은 AO-1과 Global Object를 참조하는 리스트）

![Variable Instantiation 실행](https://poiemaweb.com/img/ec_14.png)

Variable Instantiation 실행: 함수 bar의 선언 처리

변수 y를 Variable Object(AO-1)에 설정한다 이때 프로퍼티는 y, 값은 undefined이다.

![Variable Instantiation 실행](https://poiemaweb.com/img/ec_15.png)

Variable Instantiation 실행: 변수 y의 선언 처리

#3.2.2.3 this value 결정
변수 선언 처리가 끝나면 다음은 this value가 결정된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.

내부 함수의 경우, this의 value는 전역 객체이다.

![this value 결정](https://poiemaweb.com/img/ec_16.png)

this value 결정

#3.3 foo 함수 코드의 실행
이제 함수 foo의 코드 블록 내 구문이 실행된다. 위 예제를 보면 변수 y에 문자열 ‘yyy’의 할당과 함수 bar가 실행된다.

#3.3.1 변수 값의 할당
지역 변수 y에 문자열 ‘yyy’를 할당할 때, 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 Variable Object를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값 ‘yyy’를 할당한다.

![변수 값의 할당](https://poiemaweb.com/img/ec_17.png)

변수 y에의 값 할당

#3.3.2 함수 bar의 실행
함수 bar가 실행되기 시작하면 새로운 실행 컨텍스트이 생성된다.

![함수 bar의 실행](https://poiemaweb.com/img/ec_18.png)

함수 bar의 실행

이전 함수 foo의 실행 과정과 동일하게 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순차적으로 실행된다.

![함수 bar의 실행 컨텍스트](https://poiemaweb.com/img/ec_19.png)

완성된 실행 컨텍스트

이 단계에서 console.log(x + y + z); 구문의 실행 결과는 xxxyyyzzz가 된다.

x : AO-2에서 x 검색 실패 → AO-1에서 x 검색 실패 → GO에서 x 검색 성공 (값은 ‘xxx’)
y : AO-2에서 y 검색 실패 → AO-1에서 y 검색 성공 (값은 ‘yyy’)
z : AO-2에서 z 검색 성공 (값은 ‘zzz’)

#### This
자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라
Call, Apply, Bind 함수에 대해 설명해달라

#### ES6
크롬 정도의 브라우저를 제외하곤 ES6 스펙에 대한 지원이 완벽하지 않다. 해결방법은 무엇인가
Babel의 기능을 한 단어로 말해달라
ES6 에서 추가된 스펙에 대해 아는대로 다 말해달라(let, const, rest parameter, class, arrow function...)
var 와 let, const의 가장 큰 차이점은 무엇인가 (function scope와 block scope의 개념에서)
Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가 

#### Graph 에서 다른 노드를 참조하는 구조를 코드로 구현 할수 있는가
 
#### 클라이언트 개발시 보안 관련 이슈
보안은 서버쪽에서 많이 신경쓰고 있지만, 프론트엔드 개발에서 보안관련 이슈는 어떠한 것들이 있는가
Wireshark 에 대해 알고 있는가
네트워크 분석툴
### 이슈공부

### HTTP HTTP2
https://www.popit.kr/%EB%82%98%EB%A7%8C-%EB%AA%A8%EB%A5%B4%EA%B3%A0-%EC%9E%88%EB%8D%98-http2/
대용량 파일 전송에서의 암호화 비용
많은 사람들은 대용량 파일을 HTTPS로 전송하면 서버 부하가 매우 커 HTTPS로 파일에 대한 해시값만 전송하고 HTTP로 파일을 서빙하는 방식을 고려하기도 합니다. 하지만 생각해봐야 할 게 있습니다. 네 Python은 느립니다, 하지만 저는 신경쓰지 않습니다 글에서 보여줬듯 CPU는 네트워크/디스크에 비하면 충분히 빠릅니다. 단순히 계산해봅시다. 대부분의 서버는 아무리 커봐야 10Gbps 수준의 백본에 연결되어 있습니다. (더 큰 백본에 연결돼있는 서버가 있을 수도 있겠지만 10Gbps 백본을 쓴다는 것 부터가 이미 성공한 서비스라는 것을 나타내는 지표죠) 여기서 의미하는 것은 대용량 파일을 클라이언트에게 전송하기 이전에 HDD의 파일 읽는 속도가 네트워크 대역폭을 따라가지 못하며 혹시나 따라갈 수 있는 시스템을 구축해두었더라 해도 네트워크 대역폭이 같은 시간동안 CPU가 처리할 수 있는 암호화 속도를 따라갈 수가 없습니다. 결과적으로 한 서버에 PCI Express 10Gbps SFP+ NIC와 PCI Express SSD를 달아두어도 CPU 사용량에는 큰 영향을 끼치지 않습니다. 단순 숫자 계산으로만 봐도 10Gbps 어댑터에 100Mbps 100명이 붙어도 겨우 "100개"의 동시 연결이니까요.

HTTPS로 해시를 전송하고 HTTP로 파일을 서빙하는 방법이 HTTPS로만 파일을 서빙하는 것보다 비효율적인 또 다른 이유는 바로 서로 다른 프로토콜로 인해 2개의 TCP 연결을 성립시켜야 한다는 점입니다. 서로 붙는 것까지 생각하면 정확히는 4개의 TCP 연결이 되겠죠. 이는 HTTPS로만 서빙하는 것보다 2배 더 많은 RTT를 필요로 하고 더불어 TCP overhead 또한 2배라는 것을 의미합니다. 윗 문단에서 이야기한 100개의 파일 다운로드 요청이라면 200개의 TCP 연결이 필요하다는 것이고 이는 총 600 RTT를 만들어냅니다.

대용량 파일 전송을 이야기하기 앞서 네트워크 대역폭과 하드디스크 속도에 대해 이야기하는 사람들은 거의 없습니다. 단순히 대용량 파일 암호화를 CPU가 해야 하니까 느릴 거다, 부하가 클 거다 라고 이야기하는 것은 깊은 생각 보다는 얕은 생각과 지식에서 나온 말 밖에 되지 않습니다. Google Drive, Dropbox, iCloud, OneDrive, CloudFlare 등 여러 클라우드, CDN 서비스는 이미 오래 전부터 작은 파일부터 대용량 파일까지 HTTPS를 통해 서빙하고 있으며 이는 네트워크 대역폭에 빗대어 볼 때 CPU의 속도는 충분히 빠르다는 것을 증명하는 셈입니다.

구글의 큰 그림, SPDY and HTTP/2
구글은 2012년에 SPDY라는 새로운 네트워킹 프로토콜을 공개 발표했습니다. 이 프로토콜은 본질적으로 다중화(multiplexing), 우선 순위(prioritizing)를 이용해 한 TCP 연결 하에 웹 페이지 로드 속도를 더 빠르게 하기 위한 프로토콜로 공개되었습니다. 이후 이 프로토콜은 HTTP/2의 기반이 되어 2015년 3월 14일, RFC 7540 표준으로 오르게 되었습니다.

HTTP/2는 이름 자체가 암시하듯 본래 암호화되지 않은 프로토콜(HTTP) 위에서도 작동하도록 되어있습니다. 하지만 다양한 웹 브라우저가 HTTP/2 지원을 추가하면서 암호화된 프로토콜에서만 HTTP/2가 작동할 수 있도록 구현을 했으며 이는 웹 브라우저 개발 팀들이, HTTP/2는 HTTPS를 지원(power)하기 위해 만들어졌다는 것을 암시하기도 합니다.

더 빠른 웹을 위한 HTTP/2는 정말로 HTTPS를 위해 만들어진 것처럼 보입니다. HTTP/1.1은 plaintext transfer protocol이었지만 HTTP/2는 binary transfer protocol로 변경되었고, 한 연결 하에 통신을 하는 방식은 HTTP보다 HTTPS에게 더 큰 효과를 가져오는 방식이기 때문입니다.

실제 HTTP/2가 오늘날 적용된 이후 많은 웹 변화를 이루어냈습니다. HTTPS를 지원하는 웹 사이트가 많아지는 변화 말이죠. 2017년 5월 W3Techs가 공개하고 있는 바에 따르면 상위 1000만 개 웹 사이트 중에 13.8%의 웹 사이트가 HTTP/2를 지원중에 있습니다. 이 성장 폭은 점점 더 커지고 있으며 CloudFlare, MaxCDN, Fastly 등 세계적인 CDN 회사들의 지원으로 누구나 쉽게 많은 곳에서 HTTP/2를 이용할 수 있게 되었습니다.

HTTP의 문제
2월, 크롬이 업데이트 되면서 네이버가 안전하지 않은 웹 사이트로 나타나는 문제가 있었습니다. 이에 대해 네이버는 "메인 페이지에는 개인정보가 들어가 있지 않고 공개된 정보가 대부분으로, 로그인 창과 검색창에는 https를 적용하고 있다"라고 밝혀 논란이 됐었습니다. 무엇이 문제인지 알아봅시다.

요즘 시대에 DNS 또한 논란이 되고 있는 이유이기도 합니다. DNS는 개발 당시에 필요에 따라 그저 간단하게 "도메인을 요청(A)하면 아이피를 보내줘!"에 맞춰 개발됐습니다. 따라서 암호화는 전혀 고려되지 않은 부분이었고 이는 DNS 스푸핑 등 해커들의 공격으로 이어지기도 했습니다. 요즘은 DNSSEC 기술을 통해 클라이언트가 받아온 DNS 정보가 실제 정보인지 검증하는 방법이 생겨났지만 암호화가 되지 않는 근본적인 문제는 해결되고 있지 않습니다.

개인정보를 주고 받는 것도 아닌데 왜 암호화를 해야할까요? 이 문제는 수많은 국가들이 시행하고 있는 인터넷 검열(internet censorship) 문제로 이어집니다. 대부분의 국가는 DPI(deep packet inspection)를 통해 인터넷 검열을 하고 있으며, 암호화되지 않은 모든 HTTP 통신을 가로채 Host 헤더를 보고 차단 여부를 판단하는 방식을 가장 많이 사용하고 있습니다. 근본적인 문제는 여기서 시작됩니다. 각 국가의 정부 또는 ISP는 사용자가 어느 사이트에 접속하는지 어떤 행동을 하는지 모두 감시할 수 있으며, 이를 이용해 어떤 사용자가 news.naver.com 이라는 도메인 요청을 보냈었고 news.naver.com에서 어느 뉴스를 보고 있는지를 통해 해당 사용자를 구분하고 활동을 감시할 수 있게 됩니다. DNS 요청 또한 중간에서 들여다보아 처음에는 a.example.com에 있다가 어느 시점에 b.example.com에 접속을 시도했다는 것을 알 수 있게 되죠. 즉, 근본적인 문제는 인터넷 검열입니다. 모든 사용자의 행동 및 정보는 보호받아야 할 권리가 있으며 누군가가 이를 들여다볼 수 있는 여지가 생기면 안됩니다.

HTTP 통신의 문제점에 대해서 아는대로 말해달라
CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가
간단한 데이터를 클라이언트로만 관리 할수 있는가, 이와 관련해서 브라우저 에서 어떠한 것들을 지원하고 있는가, 예를 들면 소셜 로그인같은 것들에 대한 브라우저 종료시 발생하는 문제에 대응 경험이 있는가


2. meta 태그
HTML문서가 어떤내용을 담고 있고, 키워드는 무엇이며, 누가 만들었는지에 대한 정보. 즉, 문서 자체의 특성

대표적인 속서값으로는 subject, keywords, title, author 등이 있다.
페이지에 대한 메타정보로 검색 엔진에서 페이지에 대한 메타정보를 데이터 베이스화 해서 검색엔진에서 검색할 때 적절한 페이지를 보여주도록 한다.
또한, 모바일에 대한 처리인 viewport를 지정할 수 있다.

3. script 태그의 위치
html에서 script 태그는 어느 위치에나 올수 있음
그러나 브라우저는 HTML의 구조와 CSS 스타일을 렌더링하는 도중 자바스크립트를 만나게 되면, 이에 대한 해석과 구현이 완료될 때까지 브라우저 렌더링을 멈추게 되는데, 이때 프리징 현상이 발생될 수 있다.
이렇게 때문에 자바스크립트의 삽입 위치에 따라 스크립트 실행순서와 브라우저 렌더링에 영향을 미치게된다.
브라우저가 렌더링이 완료된 상태에서 스크립트가 실행되기 때문에 화면이 뜬 후 스크립트를 읽는다.
document.onload 등을 사용하지 않기 때문에 대부분의 스크립트의 위치로 추천되는 위치다.

4. 이벤트 버블링, 캡쳐링
이벤트 버블링 - 하위 엘리먼트에서 상위 엘리먼트로 이벤트가 전파되는 특성

```

<body>
    <div class="one">
        <div class="two">
            <div class="three">
            </div>
        </div>
    </div>
</body>
<script>

var divs = document.querySelectorAll('div');
divs.forEach(function(div) {
    div.addEventListener('click', logEvent);
});

function logEvent(event) {
    console.log(event.currentTarget.className);
}
</script>
```

이벤트 캡쳐링 - 버블링의 반대방향으로 진행
```
<body>
    <div class="one">
        <div class="two">
            <div class="three">
            </div>
        </div>
    </div>
</body>

<script>

var divs = document.querySelectorAll('div');
divs.forEach(function(div) {
    div.addEventListener('click', logEvent, {
        // 캡쳐링으로 설정. default는 false이므로 버블링으로 동작한다. 
        capture: true
    });
});

function logEvent(event) {
    console.log(event.currentTarget.className);
}
</script>
```    
#### 크로스 도메인 이슈 (CORS)
웹 개발시 주요한 이슈중 하나로, 웹 개발을 하다보면 어떤 경로던 이 이슈를 마주하게 된다.
동일 출처 정책(same-origin-policy)은 하나의 웹 페이지에서 다른 도메인 서버에 요청하는 것을 제한하는 것이다. 제한하는 이유는 간단한데, 내가 네이버라고 가정해보자.
누군가 다른 포탈 서비스를 만들고, 네이버에서 검색한 결과만 가져온다면 문제가 되지 않을까? 때문에 보통의 브라우저에서는 외부 도메인으로의 Ajax로 요청을 보낼 때, cors를 체킹한다.
아래는 크롬에서 발생하는 cors 에러창이다.

헤더방법
response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
response.setHeader("Access-Control-Allow-Headers", "x-requested-with");

response.setHeader("Access-Control-Allow-Origin", "*");
* 는 모든 도메인에 대해 허용하겠다는 의미. 즉 어떤 웹사이트라도 이 서버에 접근하여 AJAX 요청하여 결과를 가져갈 수 있도록 허용하겠다는 의미.
만약 보안 이슈가 있어서 특정 도메인만 허용해야 한다면 * 대신 특정 도메인만을 지정할 수 있음.

(참고로 HTML5 부터는 Form 과 Ajax 요청을 구분할 수 있는 Header가 추가됨.)
CORS를 해결하는 유명한 방법 중 하나가 JSONP를 사용하는 것이다
<script/> 태그는 same-origin-policy (SOP) 정책에 속하지 않는다는 사실을 근거로, 서로 다른 도메인간의 javascript 호출을 위하여 jsonp (JSON with Padding) 이 사용되었다.
jsonp를 사용하기 위해서는 필수적으로 서버단에서 jsonp의 포맷을 따라야한다. 이것은 jsonp를 사용하기 위한 “규칙”이다.
여기서 script 태그는 javascript 내용을 포함시킨 것이 아니라 실행시킨 것이다.
아래 코드는 jsonp를 호출할 script태그를 동적으로 생성하는 코드다. 물론 생성과 동시에 실행시킨다.
```
var script = document.createElement('script'); 
script.src = '//kingbbode.com/jsonp?callback=parseResponse';
document.getElementsByTagName('head')[0].appendChild(script); 
function parseResponse(data){ 
  //callback method 
}
```
### JSONP 예제 필요
### Vanila js 
http://www.comworld.co.kr/news/articleView.html?idxno=49245


#### 클로저를 사용하는 예 D3.js
```
function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
``` 
n에 접근을 못하게 하며 basis라는 새로운 함수로  wrapping하여 return 한다.
# HTML 질문 
### `DOCTYPE`은 무엇을 하나요? 
**DOCTYPE**은 **document type**의 약어입니다.
**DOCTYPE**은 항상 **DTD(Document Type Definition)**와 관련됩니다.
**DTD**는 특정 문서가 어떻게 구성되어야 하는지 정의합니다(예시: `button`은 `span`을 포함할 수 있지만, `div`는 그럴 수 없다.), 반면, **DOCTYPE**은 문서가 _대략_ 존중할만한 **DTD**를 선언합니다. (예시: 이 문서는 HTML DTD를 존중한다.)

웹 페이지의는 DOCTYPE 선언이 필요합니다. 유저 에이전트에게 문서가 존중하는 HTML 사양의 버전을 알리는데 사용됩니다.
유저 에이전트가 올바른 DOCTYPE을 인식하면, 문서를 읽는데에 DOCTYPE과 일치하는 **no-quirks mode**를 트리거합니다.
유저 에이전트가 올바른 DOCTYPE을 인식하지 못하면, **quirks mode**를 트리거합니다.

HTML5 표준에 대한 DOCTYPE 선언은 `<!DOCTYPE html>`입니다.

###### 참고자료

- https://html.spec.whatwg.org/multipage/syntax.html#the-doctype
- https://html.spec.whatwg.org/multipage/xhtml.html
- https://quirks.spec.whatwg.org/

[[↑] Back to top](#html-질문)

### 여러 언어로 되어 있는 콘텐츠의 페이지 
HTTP 요청을 서버에 보내면, 대개 요청하는 유저 에이전트가 `Accept-Language` 헤더와 같은 기본 언어 설정에 대한 정보를 보냅니다. 그 다음 서버는 이 정보를 사용하여 해당 언어가 제공 가능한 경우, 해당 언어 버전의 문서를 반환할 수 있습니다. 반환된 HTML 문서는 `<html lang="en">...</html>`과 같이 `<html>` 태그에 `lang` 속성을 선언해야 합니다.

백엔드에서, HTML 마크업은 YML 또는 JSON 형식으로 저장된 특정 언어에 대한 `i18n` placeholder와 내용을 포함합니다. 그 다음 서버는 일반적으로 백엔드 프레임워크의 도움을 받아 특정 언어로 HTML 페이지를 동적 생성합니다.

#### 크롬 디버그
https://www.vobour.com/%EB%8B%B9%EC%8B%A0%EC%9D%B4-%EB%AA%A8%EB%A5%BC-%EC%88%98%EB%8F%84-%EC%9E%88%EB%8A%94-%ED%81%AC%EB%A1%AC-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%BD%98%EC%86%94-%EA%B8%B0%EB%8A%A5%EB%93%A4-things-you-p

https://subicura.com/2018/02/14/javascript-debugging.html

###### 참고자료

- https://www.w3.org/International/getting-started/language

[[↑] Back to top](#html-질문)

### 다국어 사이트를 디자인하거나 개발할 때 주의해야할 사항은 무엇인가요?

- HTML에 `lang` 속성을 사용합니다.
- 사용자를 그들의 모국어로 안내합니다 - 사용자가 번거롭지 않도록 쉽게 국가/언어를 변경할 수 있도록 합니다.
- 텍스트를 포함한 이미지를 사용하는 것은 확장가능한 접근이 아닙니다 - 이미지에 텍스트를 배치하는 것은 잘 보이고 시스템 글꼴이 아닌 글꼴을 모든 컴퓨터에 표시하는데 여전히 널리 사용되는 방법입니다. 그러나 이미지에 텍스트를 번역하려면, 텍스트 문자열에 각 언어에 대해 만들어진 별도 이미지가 필요합니다. 이 같은 대체 방식이 늘어나면 금방 통제가 어려워집니다.
- 단어/문장 길이 제한 - 일부 언어는 다른 언어로 작성될 때 더 길어질 수도 있습니다. 디자인에 레이아웃이나 오버 플로우 문제 발생에 주의하세요. 디자인에 필요한 텍스트의 양을 정하거나, 디자인이 꺠질 수 있는 디자인은 하지 않도록 하는 것이 가장 좋습니다. 문자 수 제한은 제목, 레이블, 버튼과 같은 항목에서 사용됩니다. 본문이나 댓글과 같이 자유롭게 흐르는 텍스트에 대해서는 문제가 되지 않습니다.
- 색상이 어떻게 이해될지에 대해 주의 깊게보세요 - 색상은 언어와 문화에 따라 다르게 인식됩니다. 적절한 색상을 사용하여 디자인해야 합니다.
- 날짜와 통화 형식 - 날짜는 종종 다른 방식으로 표현됩니다. 예) 미국의 "May 31, 2012" vs. 유럽의 "31 May 2012".
- 번역된 문자열을 연결하지 않습니다 - `"오늘의 날짜는 " + date + "입니다"` 와 같은 것은 하지마세요. 단어의 순서가 다른 언어에서는 문자가 망가지게됩니다. 대신 각 언어에 대한 매개변수와 함께 템플릿 스트링을 사용하세요. 예를 들면, 영어와 한국어로된 다음 두 문장을 보세요. `I will travel on {% date %}`, `나는 {% date %}에 여행 갈거야`. 변수의 위치는 언어의 문법에 따라 달라집니다.
- 언어를 읽는 방향 - 영어는 왼쪽에서 오른쪽으로, 위에서 아래로 읽지만, 전통적인 일본어는 위에서 아래로, 오른쪽에서 왼쪽으로 읽습니다.

###### 참고자료

- https://www.quora.com/What-kind-of-things-one-should-be-wary-of-when-designing-or-developing-for-multilingual-sites

[[↑] Back to top](#html-질문)

### `data-`속성은 무엇에 좋은가요?

JavaScript 프레임워크가 인기있기 전에, 프론트엔드 개발자는 비표준 속성, DOM 추가 프로퍼티 등의 조작없이, DOM 자체에 추가적인 데이터를 저장하기 위해 `data-`속성을 사용했었습니다. 이는 적절한 속성이나 요소가 없는 페이지나 애플리케이션에 사용자정의 데이터를 비공개로 저장하기 위한 것입니다.

요즘에는, `data-`속성을 사용하는 것을 권장하지 않습니다. 그 이유 중 하나는 사용자가 브라우저의 inspect 기능를 사용하여 데이터 속성을 쉽게 수정할 수 있다는 것입니다. 데이터 모델은 JavaScript 자체에 더 잘 저장되며, 라이브러리나 프레임워크의 데이터 바인딩을 통해 DOM을 업데이트된 상태로 유지하는 것이 더 낫습니다.  
 

### `cookie`, `sessionStorage`, `localStorage` 사이의 차이점을 설명하세요.

위 세 가지 기술은 모두 클라이언트 측에서 값을 저장하는 key-value 저장소 매커니즘입니다. 모두 문자열로만 값을 저장할 수 있습니다.

|                                   | `cookie`                                                         | `localStorage` | `sessionStorage` |
| --------------------------------- | ---------------------------------------------------------------- | -------------- | ---------------- |
| 생성자                            | 클라이언트나 서버. 서버는 `Set-Cookie` 헤더를 사용할 수 있습니다 | 클라이언트     | 클라이언트       |
| 만료                              | 수동으로 설정                                                    | 영구적         | 탭을 닫을 때     |
| 브라우저 세션 전체에서 지속       | 만료 설정 여부에 따라 다름                                       | O              | X                |
| 모든 HTTP 요청과 함께 서버로 보냄 | 쿠키는 `Cookie` 헤더를 통해 자동 전송됨                          | X              | X                |
| 용량 (도메인당)                   | 4kb                                                              | 5MB            | 5MB              |
| 접근성                            | 모든 윈도우                                                      | 모든 윈도우    | 같은 탭          |

###### 참고자료

- https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
- http://tutorial.techaltum.com/local-and-session-storage.html

[[↑] Back to top](#html-질문)

### `<script>`, `<script async>`, `<script defer>` 사이의 차이점을 설명하세요.

- `<script>` - HTML 파싱이 중단되고, 스크립트를 즉시 가져오고 실행되며, 스크립트 실행 후 HTML 파싱이 다시 시작됩니다.
- `<script async>` - 이 스크립트는 HTML 파싱과 병렬적으로 가져오며, 가능할 때 즉시 실행됩니다(아마 HTML 파싱이 끝나기 전). 스크립트가 페이지의 다른 스크립트들과 독립적인 경우 `async`를 사용하세요. 예) analytics.
- `<script defer>` - 이 스크립트는 HTML 파싱과 병렬적으로 가져오지만, 페이지 파싱이 끝나면 실행됩니다. 이 것이 여러개 있는 경우, 각 스크립트는 페이지에 등장한 순서대로 실행됩니다. 스크립트가 완전히 파싱된 DOM에 의존되는 경우 `defer` 속성은 스크립트를 실행하기 전에 HTML이 완전히 파싱되도록 하는데 유용합니다. `<body>`의 끝부분에 일반 `<script>`를 두는 것과 별 차이가 없습니다. `defer` 스크립트는 `document.write`를 포함하면 안됩니다.

주의: `src` 속성이 없는 스크립트 태그는 `async` 와 `defer` 속성이 무시됩니다.

###### 참고자료

- http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html
- https://stackoverflow.com/questions/10808109/script-tag-async-defer
- https://bitsofco.de/async-vs-defer/

[[↑] Back to top](#html-질문)

### 왜 일반적으로 CSS `<link>` 태그를 `<head></head>` 태그 사이에 위치시키고, JS `<script>` 태그를 `</body>` 직전에 위치시키는 것이 좋은 방법인가요? 다른 예외적인 상황을 알고있나요?

**`<head>` 안에 `<link>`를 넣는 이유**

`<link>`를 `<head>` 안에 넣는 것은 최적화된 웹사이트를 구출할 때 적절한 명세의 일부입니다. 페이지가 처음로드되면 HTML과 CSS가 동시에 파싱됩니다. HTML은 DOM(Document Object Model)을 만들고 CSS는 CSSOM (CSS Object Model)을 만듭니다. 두 가지 모두 웹사이트에서 시각적인 부분을 만드는데 필요하므로, 빠른 "first meaningful paint"를 가능하게 합니다. 이 점진적 렌더링은 사이트의 성능 점수에서 측정되는 사이트 최적화의 범주입니다. 문서 최하단에 스타일시트를 두는 것은 많은 브라우저에서 점진적 렌더링을 금지하게 되는 것입니다. 몇몇 브라우저는 스타일이 변경되면 페이지의 요소를 다시 그리는 것을 피하기 위해 렌더링을 차단합니다. 그렇게되면 사용자는 빈 하얀 페이지를 보게됩니다.

그 외에도 상단에 배치하면 페이지가 점진적으로 렌더링되기 때문에 UX가 향상됩니다. 문서 맨 아래에 CSS 를 두는 것은 Internet Explorer 를 비롯한 많은 브라우저에서 점진적 렌더링을 금지시키는 것입니다. 몇몇 브라우저는 스타일이 변경되면 페이지의 요소를 다시 그리지 않아도 되도록 렌더링을 차단합니다. 사용자는 빈 하얀 페이지에서 멈추게 됩니다. 또한 스타일이 없는 내용이 잠깐 보이는 것을 방지합니다. 다른 경우에는 스타일되지 않은 내용이 깜빡일 수 있습니다(flashes of unstyled content: FOUC).

**`</body>` 직전에 `<script>`를 넣는 이유**

`<script>`는 다운로드되고 실행되는 동안 HTML 파싱을 차단합니다. 스크립트를 맨 아래에 두면 HTML을 먼저 파싱하여 사용자에게 표시할 수 있습니다.

스크립트에 `document.write()`가 있을 때는 `<script>`를 아래쪽에 두는 것이 예외적일 수 있습니다만, 요즘은 `document.write()`를 사용하지 않는 것이 좋습니다. 또한, `<script>`를 맨 아래에 두면, 브라우저가 전체 문서가 파싱될 때까지 스크립트 다운로드를 시작할 수 없다는 것을 의미합니다. 이렇게하면 DOM 요소를 조작해야하는 코드가 오류를 발생시키지 않고 전체 스크립트를 중지시키지 않습니다. `<head>`에 `<script>`를 넣어야하는 경우, `defer` 속성을 사용하세요. HTML을 파싱한 후에 스크립트를 다운로드하고 실행하는 것과 같은 효과가 있습니다.

###### 참고자료

- https://developer.yahoo.com/performance/rules.html#css_top
- https://www.techrepublic.com/blog/web-designer/how-to-prevent-flash-of-unstyled-content-on-your-websites/
- https://developers.google.com/web/fundamentals/performance/critical-rendering-path/

[[↑] Back to top](#html-질문)

### 프로그레시브 렌더링이 무엇인가요?
### PWA 공부!

프로그레시브 렌더링이란 콘텐츠를 가능한한 빠르게 표시하기 위해 웹 페이지의 성능을 향상시키는 데 사용되는 기술입니다. (특히, 인식되는 로딩 시간을 향상시킵니다)

예전에는 광대역 인터넷을 사용하기도 했지만 불안정한 모바일 데이터 연결이 점점 인기를 끌면서 최근 개발에 있어서도 여전히 유용합니다!

관련 기술 예시:

- 이미지 지연 로딩 - 페이지의 이미지를 한꺼번에 로딩하지 않습니다. JavaScript를 사용하여 사용자가 이미지를 표시하는 페이지 부분으로 스크롤 할 때 이미지를 로드 할 수 있습니다.
- 보이는 콘텐츠의 우선순위 설정 (또는 스크롤 없이 볼 수 있는 렌더링) - 가능한 한 빨리 표시하기 위해 사용자 브라우저에서 렌더링될 페이지에 필요한 최소한의 CSS/콘텐츠/스크립트 만 포함하면 `deferred` 스크립트를 사용하거나 `DOMContentLoaded`/`load` 이벤트를 사용하여 다른 리소스와 내용을 로드할 수 있습니다.
- 비동기 HTML 프래그먼트 - 페이지의 백엔드에서 HTML 페이지의 일부를 브라우저로 가져옵니다. 이 기술에 대한 자세한 내용은 [여기](http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/)에서 찾을 수 있습니다.
 

### 이미지 태그에 `srcset` 속성을 사용하는 이유는 무엇인가요? 이 속성의 컨텐츠를 평가할 때 브라우저가 사용하는 프로세스를 설명하세요.

기기의 디스플레이 너비에 따라 다른 이미지를 사용자에게 제공하려는 경우 `srcset` 속성을 사용합니다 - 레티나 디스플레이를 통해 장치에 고품질 이미지를 제공하여 사용자 경험을 향상시키고, 저해상도 이미지를 저사양 기기에 제공하여 성능을 높이고 데이터 낭비를 줄입니다. (왜냐하면 더 큰 이미지를 제공하는 것은 눈에 보일 정도의 차이가 없기 때문). 예를 들면: `<img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w" src="..." alt="">`는 클라이언트의 해상도에 따라 브라우저에 small, medium, large `.jpg` 그래픽을 표시하도록 지시합니다. 첫 번째 값은 이미지 이름이고 두 번째 값은 픽셀 단위의 이미지 너비입니다. 320px 너비의 경우, 다음과 같은 계산을 따릅니다

- 500 / 320 = 1.5625
- 1000 / 320 = 3.125
- 2000 / 320 = 6.25

클라이언트의 해상도가 1x 일 경우, 1.5625가 가장 가깝고 `small.jpg`에 해당하는 `500w`가 브라우저에 의해 선택됩니다.

해상도가 레티나 (2x)인 경우 브라우저는 최소값에서 가장 위로 가까운 해상도를 사용합니다. 500w (1.5625)는 1보다 크고 이미지가 보기 좋지 않을 수 있기 때문에 선택하지 않는다는 것을 의미합니다. 그래서 브라우저는 계산 결과 비율값이 2에 가까운 1000w (3.125) 이미지를 선택합니다.

`srcset`는 데스크탑 디스플레이처럼 거대한 이미지를 필요로하지 않기 때문에 화면 장치를 좁히는 작은 이미지 파일을 제공하고자하는 문제를 해결합니다.

`srcset`는 화면이 작은 기기에서 데스크탑 디스플레이처럼 큰 이미지가 필요하지 않기 때문에 작은 이미지 파일을 제공하는 문제를 해결합니다 — 또한 선택적으로 고해상도/저해상도 화면에 다른 해상도 이미지를 제공할 수도 있습니다.  
### CSS 선택자 특이성은 무엇이며 어떻게 작동합니까?

브라우저는 CSS 규칙의 특수성에 따라 요소에 표시할 스타일을 결정합니다. 브라우저는 이미 특정 요소와 일치하는 규칙을 결정했다고 가정합니다. 일치하는 규칙들 가운데, 다음에 기초하여 각 규칙에 대해 특수성, 네개의 쉼표로 구분된 값,`a, b, c, d`가 계산됩니다.

1.  `a`는 인라인 스타일이 사용되고 있는지 여부입니다. 속성 선언이 요소에서 인라인 스타일이면 'a'는 1 이고, 그렇지 않으면 0 입니다.
2.  `b`는 ID 셀렉터의 수입니다.
3.  `c`는 클래스, 속성 및 가상 클래스 선택자의 수입니다.
4.  `d`는 태그 및 유사 요소 선택자의 수입니다.

결과적인 특정성은 점수가 아니라, 컬럼마다 비교할 수 있는 가치들의 행렬입니다. 선택자를 비교하여 가장 높은 특이성을 갖는 항목을 결정할 때 왼쪽에서 오른쪽으로 보고 각 열의 가장 높은 값을 비교하세요. 따라서 `b`열의 값은 `c`와 `d`열에 있는 값을 무시합니다. 따라서 `0,1,0,0`의 특이성은 `0,0,10,10`중 하나보다 큽니다.

동등한 특이성의 경우: 최신 규칙은 중요한 규칙입니다. 스타일 시트에 동일한 규칙을 두 번 작성한 경우(내부나 외부에 관계 없이) 스타일 시트의 하위 규칙이 스타일 될 요소에 더 가까우므로 더 구체적으로 적용됩니다.

필자는 필요하다면 쉽게 재정의할 수 있도록 낮은 특정성 규칙들을 작성할 것입니다. CSS UI 컴포넌트 라이브러리 코드를 작성할 때 특이성을 높이거나 `!important`를 사용하기 위해 라이브러리 사용자가 지나치게 복잡한 CSS 규칙을 사용하지 않고도 이를 무시할 수 있도록 특이성이 낮은 것이 중요합니다.

###### 참고자료

* <https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/>
* <https://www.sitepoint.com/web-foundations/specificity/>

### "Resetting"과 "Normalizing" CSS 의 차이점은 무엇입니까? 당신은 무엇을 선택할 것이며, 그 이유는 무엇입니까?

* **Resetting** - Resetting 은 요소의 모든 기본 브라우저 스타일을 제거하기 위한 것입니다. 예 : `margin`, `padding`,`font-size`는 같은 값으로 재설정됩니다. 일반적인 타이포그래피 요소에 대한 스타일을 재 선언해야합니다.

* **Normalizing** - Normalizing 는 모든 것을 "정리"하는 것이 아니라 유용한 기본 스타일을 보존합니다. 또한 일반적인 브라우저 종속성에 대한 버그를 수정합니다.

필자는 나만의 스타일링을 많이 해야 하고 보존할 기본 스타일링이 필요하지 않도록 매우 맞춤화되었거나 자유로운 사이트 디자인을 가지고 있을 때 리셋을 선택합니다.

###### 참고자료

* <https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css>

### `float`이 어떻게 작동하는지 설명하세요.

Float 은 CSS 위치 지정 속성입니다. Float 된 요소는 페이지의 흐름의 일부로 남아 있으며 페이지의 흐름에서 제거되는 'position : absolute'요소와 달리 다른 요소 (예 : 플로팅 요소 주위로 텍스트가 흐르게 됨)의 위치 지정에 영향을 줍니다.

CSS `clear` 속성은`left`/`right`/`both` float 엘리먼트 아래에 위치하도록 사용될 수 있습니다.

부모 요소에 float 된 요소만 있으면 그 높이는 무효가 됩니다. 컨테이너의 플로팅된 요소 다음에 있지만 컨테이너가 닫히기 전에 float 를 clear 하면 해결할 수 있습니다.

`.clearfix` 핵은 영리한 CSS 의사 선택자 (`: after`)를 사용하여 실수를 제거합니다. 상위 클래스에 overflow 를 설정하는 대신 추가 클래스 `clearfix`를 적용합니다. 그런 다음이 CSS 를 적용하십시오:

```css
.clearfix:after {
  content: ' ';
  visibility: hidden;
  display: block;
  height: 0;
  clear: both;
}
```

양자택일로, 부모 요소에 `overflow : auto` 또는 `overflow : hidden` 속성을 주면 자식 요소 내부에 새로운 블록 포맷 컨텍스트을 설정하고 자식을 포함하도록 확장합니다.

###### 참고자료

* <https://css-tricks.com/all-about-floats/>

### `z-index`와 쌓임 맥락(stacking context)이 어떻게 형성되는지 설명하세요.

### relative도 갖는지 테스트

CSS 의 `z-index`속성은 요소의 겹치는 요소의 순서를 제어합니다. `z-index`는 `static`이 아닌 `position` 값을 갖는 요소에만 영향을 줍니다.

`z-index` 값이 없으면 DOM에 나타나는 순서대로 요소가 쌓이게 됩니다 (동일한 레이어에서 가장 낮은 레이어의 맨 위에 나타납니다). 정적이지 않은(non-static) 위치 지정 요소 (및 해당 하위 요소)는 HTML 레이어 구조와 상관없이 기본 정적 위치 지정을 사용하여 항상 요소 위에 나타납니다.

쌓임 맥락(stacking context)은 레이어 집합을 포함하는 요소입니다. 쌓임 맥락(stacking context) 지역 내에서 자식의 `z-index` 값은 문서 루트가 아닌 해당 요소를 기준으로 설정됩니다. 해당 컨텍스트 외부의 레이어 — 즉 로컬 쌓임 맥락의 형제 요소 — 그 사이의 레이어에 어울릴 수 없습니다. 요소 B 가 요소 A 의 상단에 위치하는 경우, 요소 A 의 하위 요소 C 는 요소 C 가 요소 B 보다 `z-index`가 더 높은 경우에도 요소 B 보다 높을 수 없습니다.

각각의 쌓임 맥락은 자체적으로 포함되어 있습니다 - 요소의 내용이 쌓인 후에는 전체 요소를 쌓임 맥락의 쌓인 순서로 고려합니다. 소수의 CSS 속성이 `opacity`가 1 보다 작고 `filter`가 `none`이 아니며 `transform`이 `none`이 아닌 새롭게 쌓임 맥락(stacking context)을 트리거합니다.

###### 참고 자료

* <https://css-tricks.com/almanac/properties/z/z-index/>
* <https://philipwalton.com/articles/what-no-one-told-you-about-z-index/>
* <https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context>

### 블록 서식 문맥(BFC)과 작동 방식을 설명하세요.

BFC(블록 서식 문맥)는 블록 박스가 배치된 웹 페이지의 시각적 CSS 렌더링의 일부입니다. Floats, absolutely로 배치된 요소,`inline-blocks`, `table-cells`, `table-caption` 그리고 `visible`(그 값이 viewport 에 전파되었을 때는 제외) 이외의 `overflow`가 있는 요소들이 새로운 블록 포맷 컨텍스트를 만듭니다.

BFC는 다음 조건 중 하나 이상을 충족시키는 HTML 박스입니다:

* `float`의 값은 `none`이 아닙니다.
* `position`의 값은 `static`도 아니고 `relative`도 아닙니다.
* `display`의 값은 `table-cell`, `table-caption`, `inline-block`, `flex` 또는 `inline-flex`입니다.
* `overflow`의 값은 `visible`이 아닙니다.

BFC 에서 각 박스의 왼쪽 바깥 가장자리는 포함하는 블록의 왼쪽 가장자리에 닿습니다 (오른쪽에서 왼쪽으로 포맷팅, 오른쪽 가장자리에서 터치).

BFC 상쇄(collapse)시 인접한 블록 레벨 박스 사이의 Vertical 마진. [마진 collapsing](https://www.sitepoint.com/web-foundations/collapsing-margins/)에 대해 자세히 읽어보세요.

###### 참고 자료

* <https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context>
* <https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/>

### clear 하는 방법에는 어떤 것이 있으며, 각각 어떤상황에 적합합니까?

* 비어있는 `div` 방법 - `<div style="clear:both;"></div>`
* Clearfix 방법 - 이와 같은 `.clearfix` 클래스를 참조하세요.
* `overflow: auto` 또는 `overflow: hidden` 방법 - 부모는 새로운 블록 서식 지정 컨텍스트를 설정하고, 확장 된 자식을 포함하도록합니다.

대규모의 프로젝트에서는 유용하게 `.clearfix` 클래스를 만들어 필요한 곳에서 사용합니다. 자식이 부모보다 크기가 경우 `overflow: hidden`은 자식의 모두 보여줄 수 없습니다.

### CSS 스프라이트는 무엇입니까? 그리고 당신이 페이지 나 사이트에 구현하는 방법도 설명해주세요.

CSS 스프라이트는 여러 이미지를 하나의 큰 이미지로 결합합니다. 일반적으로 아이콘에 사용되는 기술(Gmail 에서 사용)입니다. 구현방법:

1.  스프라이트 생성기를 사용하여 여러 이미지를 하나로 묶어 적절한 CSS 를 생성합니다.
2.  각 이미지는 `background-image`,`background-position` 및`background-size` 속성이 정의 된 해당 CSS 클래스를 갖습니다.
3.  해당 이미지를 사용하려면 요소에 해당 클래스를 추가하십시오.

**장점:**

* 여러 이미지에 대한 HTTP 요청 수 줄이기(스프라이트 시트 당 하나의 단일 요청 만 필요합니다.) 그러나 HTTP2 를 사용하면 여러 이미지를로드하는 것이 더 이상 중요하지 않습니다.
* `: hover`의 상태에서만 나타나는 이미지가 필요할 때 다운로드되지 않는 이미지를 미리 다운로드하여 깜박임이 보이지 않습니다.

###### 참고 자료

* <https://css-tricks.com/css-sprites/>

### 브라우저 별 스타일링 문제를 해결하는 방법에 대해 어떻게 생각하십니까?

* 문제 및 문제를 일으키는 브라우저를 식별한 후에는 해당 브라우저가 사용 중일 때만 로드되는 별도의 스타일 시트를 사용하십시오. 하지만 이 기술을 사용하려면 서버 측 렌더링이 필요합니다.
* 이미 이러한 스타일링 문제를 처리하고 있는 Bootstrap 과 같은 라이브러리를 사용하십시오.
* `autoprefixer`를 사용하여 벤더 프리픽스를 코드에 자동으로 추가하십시오.
* Reset CSS 또는 Normalize.css 를 사용합니다.

### 기능이 제한된 브라우저의 페이지는 어떻게 처리합니까? 어떤 기술/프로세스를 사용하십니까?

* 우아한 퇴화 - 최신 브라우저를 위한 응용 프로그램을 구축하는 동시에 그것이 구형 브라우저에서도 계속 작동하도록 하는 구축방법.
* 점진적 향상 - 기본 수준의 사용자 환경에 대한 응용 프로그램을 구축하지만 브라우저가 이를 지원할 경우 기능을 강화하는 방법이 있습니다.
* [caniuse.com](https://caniuse.com/)을 사용하여 기능 지원을 확인하십시오.
* 자동 공급 프리픽스인 Autoprefixer 삽입.
* [Modernizr](https://modernizr.com/)를 사용하여 미래 간파.

### 콘텐츠를 시각적으로 숨기고(화면 판독기에서만 사용할 수 있게 만드는)다양한 방법은 무엇입니까?

이러한 기술은 접근성 (a11y)에 관련이 있습니다.

* `visibility: hidden`. 그러나 요소는 아직 페이지의 흐름에 여전히 공간을 차지하고 있습니다.
* `width: 0; height: 0`. 요소가 화면의 어떤 공간도 차지하지 않도록하십시오. 결과적으로 보이지 않습니다.
* `position: absolute; left: -99999px`. 화면 외부에 배치합니다.
* `text-indent: -9999px`. 이것은 `block`인 엘리먼트 내의 텍스트에서만 작동합니다.
* 메타 데이터. 예를 들어, Schema.org, RDF 및 JSON-LD 를 사용합니다.
* WAI-ARIA. 웹 페이지의 액세스 가능성을 높이는 방법을 지정하는 W3C 기술 사양입니다.

WAI-ARIA 가 이상적인 해결책이라 하더라도 저는 `absolute` 접근법을 택할 것입니다. 대부분의 요소에서 작동하며 간단한 기술입니다.

###### 참고자료

* <https://www.w3.org/TR/wai-aria-1.1/>
* <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA>
* <http://a11yproject.com/>

### 혹시 그리드 시스템을 사용하나요? 만약 그렇다면, 당신은 어떤것을 선호합니까?

나는 `float` 기반 그리드 시스템을 좋아한다. 왜냐하면 여전히 기존의 다른 시스템들(flex, grid) 중에서도 가장 많은 브라우저를 지원하기 때문입니다. 이것은 부트 스트랩에서 수년 동안 사용되었으며, 효과가 있다는 것이 입증되었습니다.
### 그리드 시스템

### 미디어 쿼리 또는 모바일 관련 layouts/CSS 를 사용하거나 구현해 보았습니까?

네. 한가지 예를 들면 여러 줄 형식의 네비게이션을 중간시점이 지나면 텝의 형태로 변환하였습니다.

### SVG 
https://spoqa.github.io/2012/06/13/bitmap-vector.html

Scalable Vector Graphics (SVG) is an XML-based markup language for describing two dimensional based  vector graphics
rect, attribute가 있다. 
SVG는 벡터를 기반으로 그래프를 그린다.

벡터 기반의 그래픽은 각 요소의 좌표를 조합하여 그림을 그리게 된다.
작은 데이터로도 도형을 그릴 수 있으며, 해상도가 바뀌거나 도형을 확대하더라도 선이 깨끗하게 표시되는 장점이 있다.
복잡한 도형은 계산해야 하는 좌표의 수가 많아서 처리하는데 시간이 많이 걸릴 수 있다.
벡터 기반의 그래픽과 반대되는 개념은 비트맵 (책에서는 픽셀 이라고 표시하고 있습니다. 래스터 raster 라는 표현도 많이 씁니다.) 기반의 그래픽이 있다.

복잡한 이미지를 효율적으로 보여줄 수 있다.
이미지를 편집하는 과정에서 손실이 많이 발생할 수 있다.
특히 확대할 경우 아래 그림처럼 계단 현상이 발생한다.

Object
<object>요소는 HTMLHTML문서 내에 직접 내장(inline)시키지 않고 SVG를 조작하는 경우에 가장 좋은 방법입니다.

SVG를 최대한 활용하려면 <object>을 사용하세요. 또는 HTTP 요청을 저장하기 위해 인라인으로 사용할 수 있지만 이미지는 캐시되지 않는 문제가 있습니다. 이미지처럼 동일하게 SVG를 사용하려면 <img>또는 background-image를 사용하세요. <iframe> 및 <embed>를 사용할 수 있겠으나 가장 좋은 방법은 아니므로 더 이상 설명은 하지 않겠습니다.

Object	Inline	Img	Background-image
CSS 조작	가능	가능	일부 inline	일부 inline
JS 조작	가능	가능	불가능	불가능
SVG 조작	가능	가능	가능	가능
인터렉티브 SVG 애니메이션	가능	가능	불가능	불가능

### screen 이 아닌 @media 속성의 예를 들려 줄 수 있습니까?

예, @ media 속성을 screen 포함하여 4 가지 종류가 있습니다 :

* all - 모든 미디어 기기 장치
* print - 프린터
* speech - 화면을 크게 읽는 스크린리더
* screen - 컴퓨터 스크린, 태블릿, 스마트 폰 등

`print` 미디어의 사용 예제 :

```css
@media print {
  body {
    color: black;
  }
}
```

### 효율적인 CSS 를 작성하는데 있어 "어려움"은 무엇입니까?

먼저 브라우저는 오른쪽선택자에서 왼쪽으로 선택자가 일치하는지 확인합니다. 브라우저는 선택자에 따라 DOM 의 요소를 필터링하고 해당 부모요소가 일치하는지 식별합니다. 선택자 체인의 길이가 짧을수록 브라우저는 해당 요소가 선택자와 일치하는지 여부를 빠르게 판별할 수 있습니다. 따라서 태그선택자와 보편적인 선택자자를 사용하지마세요. 그것들은 다수의 요소가 브라우저와 매치되기 때문에 부모가 일치하는지 여부를 판단하기 위해 많은 작업을 해야합니다.

[BEM (Block Element Modifier)](https://bem.info/)의 방법론에서는 모두 단일 클래스를 갖고, 계층구조가 필요한 곳에서는 클래스의 이름이 확장되기를 권장합니다. 따라서 선택자를 쉽고 효율적으로 재정의 할 수 있습니다.

어떠한 CSS 속성이 리플로우, 리페인트 그리고 합성을 트리거 하는지 알아 두십시오. 가능하면 레이아웃(트리거 리플로우)를 변경하는 스타일은 작성하지 마십시오.

###### 참고 자료

* <https://developers.google.com/web/fundamentals/performance/rendering/>
* <https://csstriggers.com/>

### CSS 전처리기를 사용하면 어떤 장단점이 있습니까?

### SASS
**장점:**

* CSS 의 유지보수성 향상됩니다.
* 중첩된 선택자를 작성하기 쉽습니다.
* 일관된 스타일링 설정을 위한 변수사용. 여러 프로젝트에 걸쳐 테마 파일을 공유할 수 있습니다.
* 반복되는 CSS 를 위한 Mixins 생성.
* 코드를 여러 파일로 나눕니다. CSS 파일도 나눌 수 있지만, 그렇게 하기 위해서는 각 CSS 파일을 다운로드하기 위한 HTTP 요청이 필요합니다.

**단점:**

* 전처리기를 위한 도구가 필요합니다. 다시 컴파일하는 시간이 느릴 수 있습니다.

### 비표준 글꼴을 사용하는 웹 디자인 디자인을 구현하는 방법은 무엇입니까?

`font-face`를 사용하고 `font-weight`가 다른 경우 `font-family`를 정의합니다.

### CSS 셀렉터에 일치하는 요소가 어떤 것인지 브라우저가 어떻게 결정되는지를 설명하시오.

이 부분은 위의 효율적인 CSS 작성에 대한 것입니다. 브라우저는 셀렉터를 오른쪽(선택자)에서 왼쪽으로 일치시킵니다. 브라우저는 선택자에 따라 DOM 의 요소를 필터링하고 부모 요소를 검사하여 일치를 판정합니다. 선택자 체인의 길이가 짧을수록, 브라우저가 해당 요소가 선택기에 일치하는지 여부를 판단할 수 있습니다.

예를 들어, 이 셀렉터 `p span`는 브라우저는 먼저 모든 `<span>`요소를 찾아 그 부모의 루트까지 모두 통과하여 `<p>`요소를 찾습니다. 특정한 `<span>`의 경우 `<p>`를 찾는 즉시 `<span>`이 일치하는 것을 알고 있으며, 그에 따라 매칭 중지합니다.

###### 참고자료

* <https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left>

### Pseudo-elements 에 대해 설명하고 그 요소가 무엇을 위해 사용되는지 설명하시오.

CSS Pseudo-element 는 Selector 에 추가된 키워드로, 선택한 요소의 특정한 부분을 스타일링 할 수 있습니다. 마크업을 수정하지 않고 (`:before`, `:after`) 텍스트 데코레이션을 위해 사용하거나 (`:first-line`, `:first-letter`) 또는 마크 업에 요소를 추가할 수 있습니다. (`content: ...` 와 결합)

* `:first-line` 과 `:first-letter` 는 텍스트를 데코레이션하는데 사용될 수 있습니다.
* 위와 같이 `.clearfix` 에 사용되어 `clear: both` 로 영역을 차지하지 않는 요소를 추가합니다.
* 툴팁의 삼각형 화살표는 `:before` 와 `:after` 를 사용합니다. 삼각형이 실제로 DOM 이 아닌 스타일의 일부로 간주되기 때문에 분리하는 것이 좋습니다. 추가적인 HTML 요소를 사용하지 않고 CSS 스타일만으로 삼각형을 그릴 수는 없습니다.

###### 참고자료

* <https://css-tricks.com/almanac/selectors/a/after-and-before/>

### 박스 모델에 대한 이해와 CSS 에서 브라우저에 다른 박스 모델로 레이아웃을 렌더링하는 방법을 설명하십시오.

CSS 박스 모델은 문서 트리의 요소에 대해 생성되고 시각적 서식 모델에 따라 배치된 사각형 상자를 나타냅니다. 각 박스에는 content 영역 (예: 텍스트, 이미지 등) 및 선택적 주변의 'padding', 'border' 및 'margin' 영역이 있습니다.

CSS 박스 모델은 다음을 계산합니다.

* 블록 요소가 차지하는 공간.
* 테두리 또는 여백이 겹치거나 붕괴되는지 여부.
* 박스의 크기.

박스 모델에는 다음과 같은 규칙이 있습니다.

* 블록 요소의 크기는 `width`, `height`, `padding`, `border`, `margin`에 의해 계산됩니다.
* `height` 가 지정되어 있지 않은 경우, 블럭 요소는 포함하고있는 내용만큼의 높이를 가질 것이고, `padding` 을 덧붙일 것입니다(아래에 float 가 없다면).
* `width` 가 지정되지 않으면, float 가 아닌 블록 요소는 (부모의 너비 - `padding`) 에 맞게 확장됩니다.
* 요소의 `height`는 내용의 `height`에 의해 계산됩니다.
* 요소의 `width`는 내용의 `width`에 의해 계산됩니다.
* 기본적으로 `padding`과 `border`는 요소의 `width`와 `height`의 일부가 아닙니다.

###### 참고자료

* <https://www.smashingmagazine.com/2010/06/the-principles-of-cross-browser-css-coding/#understand-the-css-box-model>

### `* { box-sizing: border-box; }` 는 무엇을 하나요? 장점은 무엇입니까?

* 기본적으로, 요소들은 `box-sizing: content-box`가 적용되고, 내용의 크기 만 고려됩니다.
* `box-sizing: border-box` 는 요소의 `width` 와 `height` 가 어떻게 계산되는지를 변경하여 `border` 와 `padding` 도 계산에 포함됩니다.
* 요소의 `height` 는 내용의 `height` + 수직 `padding` + 수직 `border` 폭에 의해 계산됩니다.
* 요소의 `width` 는 내용의 `width` + 수평 `padding` + 수평 `border` 폭에 의해 계산됩니다.

### CSS 의 `display` 속성은 무엇이며 사용법에 대한 몇 가지 예를 들 수 있습니까?

* `none`, `block`, `inline`, `inline-block`, `table`, `table-row`, `table-cell`, `list-item`.

TODO

### `inline` 과 `inline-block` 의 차이점은 무엇입니까?

좋은 비교를 위해 `block` 과도 비교해 볼 것입니다.

|                                  | `block`                                                                                     | `inline-block`                                                   | `inline`                                                                                                                                                                          |
| -------------------------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 크기                             | 부모 컨테이너의 너비를 채 웁니다.                                                           | 내용에 따라 달라집니다.                                          | 내용에 따라 달라집니다.                                                                                                                                                           |
| 위치                             | 새 줄에서 시작하고 그 옆에 HTML 요소를 허용하지 않습니다 (`float`을 추가 할 때를 제외하고). | 다른 콘텐츠와 함께 흐르고 다른 요소는 옆에 있는 것을 허용합니다. | F 다른 콘텐츠와 함께 흐르고 다른 요소는 옆에 있는 것을 허용합니다.                                                                                                                |
| `width`, `height` 지정 가능 여부 | 가능                                                                                        | 가능                                                             | 불가능. 설정되면 무시됩니다.                                                                                                                                                      |
| `vertical-align` 정렬 가능 여부  | 불가능                                                                                      | 불가능                                                           | 불가능                                                                                                                                                                            |
| margin 및 padding                | 모든 방향에서 가능.                                                                          | 모든 방향에서 가능.                                               | 수평방향만 가능. 세로방향을 지정하면 레이아웃에 영향을 주지 않습니다. `border` 와 `padding` 이 콘텐츠 주위에 시각적으로 나타나는 경우에도 수직영역은 `line-height` 에 의존합니다. | 
| Float | - | - | 수직 margin 과 padding 을 설정할 수 있는 `block` 엘리먼트와 같습니다. |

### `relative`, `fixed`, `absolute` 와 `static` 요소의 차이점은 무엇입니까?

위치가 정해진 요소는 계산된 `position` 속성이 `relative`, `absolute`, `fixed` 또는 `sticky`인 요소입니다.

* `static` - 기본 위치. 요소는 평소와 같이 페이지에 위치합니다. `top`, `right`, `bottom`, `left` 및 `z-index` 속성은 적용되지 않습니다.
* `relative` - 요소의 위치는 레이아웃을 변경하지 않고 자체에 상대적으로 조정됩니다. (따라서 배치되지 않은 요소의 간격을 남겨 둡니다.)
* `absolute` - 요소는 페이지의 평소 위치에서 제거되고 가장 가까운 위치에 `relative` 부모 블록이 있는 경우 지정된 위치에 배치됩니다. 그렇지 않으면 최상위 블록과 관련됩니다. absolute 로 배치된 박스는 여백을 가질 수 있으며 다른 여백과 충돌하지 않습니다. 이 요소는 다른 요소의 위치에 영향을 주지 않습니다.
* `fixed` - 요소는 페이지의 평소 위치에서 제거되고 뷰포트를 기준으로 지정된 위치에 배치되며 스크롤 할 때 이동하지 않습니다.
* `sticky` - 스티키 포지셔닝은 `relative` 와 `fixed` 의 하이브리드입니다. 요소는 지정된 임계 값을 넘을 때까지 `상대적` 위치로 처리되며, 특정 지점에서 `고정된` 위치로 처리됩니다. 

### 새로운 CSS Flexbox 또는 그리드 스펙을 사용해본 적이 있나요?

예. Flexbox는 주로 1차원 레이아웃을 대상으로 하며 Grid는 2차원 레이아웃을 대상으로 합니다.

Flexbox는 CSS에서 컨테이너 안에 있는 요소의 수직 중심, sticky footer 등과 같은 많은 일반적인 문제들을 해결합니다. Bootstrap과 Bulma는 Flexbox를 기반으로 하고, 이것은 아마도 요즘 배치도를 만드는 데 권장되는 방법일 것입니다. 이전에 Flexbox를 사용해 보았지만 `flex-grow`를 사용할 때 일부 브라우저에서 비호환성 문제(Safari)가 발생했습니다. 그래서 백분율로 나타낸 폭을 계산하기 위해 `inline-blocks`과 수학을 사용한 코드로 다시 써야했는데, 이것은 좋은 경험이 아니었습니다.

Grid는 그리드 기반의 레이아웃을 생성하기 위한 가장 가장 직관적인 접근법이지만(더 좋을 것입니다!), 현재 브라우저 지원은 광범위 하지 않습니다.

[[↑] 맨 위로](#css-questions)

###### 참고자료

* <https://philipwalton.github.io/solved-by-flexbox/>

### 반응형 웹사이트를 코딩하는 것과 모바일 우선 전략을 사용하는 것 사이의 차이점을 설명하시오.

이 두가지 접근법은 배타적이지 않습니다.

반응형 웹사이트를 만드는 것은 일부 요소가 미디어 쿼리를 통해 장치의 화면 크기(일반 적으로 뷰포트 너비)에 따라 크기나 기타 기능을 조정하도록 반응함을 의미합니다. (예: 작은 장치에서 글꼴 크기를 줄임)

```css
@media (min-width: 601px) { 
  .my-class { 
    font-size: 24px;
  }
}
@media (max-width: 600px) {
  .my-class { 
    font-size: 12px;
  }
}
```

모바일 우선 전략 또한 반응적이지만, 모바일 장치에 대한 모든 스타일을 정의해야하며 나중에 다른 장치에 대한 특정 규칙을 추가해야합니다. 이전 예를 따르면 다음과 같습니다.

```css
.my-class { 
  font-size: 12px;
}

@media (min-width: 600px) {
  .my-class { 
    font-size: 24px;
  }
}
```

모바일 우선 전략은 2가지 주요 장점을 가지고 있습니다.

* 모바일 장치에서 적용되는 모든 규칙이 미디어 쿼리에 대해 유효성 검사를 받을 필요가 없으므로 모바일 장치에서 더 뛰어난 성능을 발휘합니다.
* 반응형 CSS 규칙과 관련하여 보다 명확한 코드를 작성해야합니다.

[[↑] 맨 위로](#css-questions)

### 반응형 디자인은 적응형 디자인과 어떻게 다른가요?

반응형 및 적응형 디자인은 서로 다른 뷰포트 사이즈, 해상도, 사용 컨텍스트 그리고 제어 메커니즘 등을 조정하여 다양한 장치에서 사용자 경험을 최적화하려고 시도합니다.

반응형 디자인은 유연성 원칙에 따라 작동합니다. 즉, 어떤 장치에서나 보기 좋은 단일 변하기 쉬운 웹 사이트입니다. 반응형 웹 사이트는 미디어 쿼리, 유연한 그리드 및 반응 형 이미지를 사용하여 다양한 요인에 따라 유연하고 변화하는 사용자 경험을 제공합니다. 마치 하나의 공이 여러개의 서로 다른 링을 통과하기 위해 커지거나 줄어드는 것과 유사합니다.

적응형 디자인는 점진적 향상의 현대적 정의에 더 가깝습니다. 하나의 유연한 디자인 대신에, 적응형 설계는 장치 및 기타 기능을 감지 한 다음 사전 정의 된 뷰포트 크기 및 기타 특성 세트를 기반으로 적절한 기능 및 레이아웃을 제공합니다. 하나의 공이 여러개의 서로 다른 링을 통과하는 대신, 후프의 크기에 따라 여러개의 공을 사용할 수 있습니다. 

[[↑] 맨 위로](#css-questions)

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design>
* <http://mediumwell.com/responsive-adaptive-mobile/>
* <https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/>

### 레티나 그래픽으로 작업 해본 적이 있습니까? 그렇다면, 언제 그리고 어떤 기술을 사용하였습니까?

저는 레티나 디스플레이를 다루기 위해 고해상도 그래픽을 사용하는 경향이 있습니다. 가장 좋은 방법은 `@media only screen and (min-device-pixel-ratio : 2) {...}`와 같은 미디어 쿼리를 사용하고 `background-image`를 변경하는 것입니다.

아이콘의 경우 해상도에 관계없이 매우 선명하게 렌더링하므로 가능하면 svg 및 아이콘 글꼴을 사용하도록 선택합니다.

또 다른 방법으로는 `windows.deviceFixeLaatio`값을 확인한 후에 `img` `src`특성을 더 높은 해상도 버전으로 대체하는 JavaScript를 사용하는 것이 있다.

[[↑] 맨 위로](#css-questions)

###### 참고자료

* <https://www.sitepoint.com/css-techniques-for-retina-displays/>

### `absolute` 포지셔닝 대신 `translate()`를 사용하는 이유가 무엇입니까? 또는 그 반대의 경우에 대해서는 어떻게 생각하십니까?, 그 이유는 무엇입니까?

`translate()`은 CSS `transform`의 값입니다. `transform`이나 `opacity`를 변경해도 브라우저의 리플로우나 리페인트가 다시 시작되지 않고 컴포지션만 실행되는 반면 절대 위치를 변경하면 '리플로우'가 발생합니다. `transform`을 사용하면 브라우저에서 이 요소에 위한 GPU 레이어를 생성되지만 절대 위치 속성을 변경하는 것은 CPU를 사용합니다. 그러므로 `translate()`가 더 효율적이며 매끄러운 애니메이션을위한 페인트 시간이 짧아집니다.

`translate()`을 사용할 때는 절대 위치를 변경할 때와 달리 원래 위치(일종의 `position: relative`)를 그대로 사용합니다. 
 

### `this`가 JavaScript 에서 어떻게 작동하는지 설명하세요.

`this`는 간단하게 설명하기 어렵습니다. JavaScript 에서 가장 혼란스러운 개념 중 하나입니다. 대략 설명하면 `this`의 값은 함수가 호출되는 방식에 따라 달라집니다.
온라인에 많은 설명이 있는데 [Arnav Aggrawal](https://medium.com/@arnav_aggarwal)의 설명이 가장 명확했습니다.
다음 규칙과 같습니다.

1.  함수를 호출할 때 `new` 키워드를 사용하는 경우 함수 내부에 있는 `this`는 완전히 새로운 객체입니다.
2.  `apply`, `call`, `bind`가 함수의 호출 / 작성에 사용되는 경우 함수 내의 `this`는 인수로 전달된 객체입니다.
3.  `obj.method()`와 같이 함수를 메서드로 호출하는 경우 `this`는 함수가 프로퍼티인 객체입니다.
4.  함수가 자유함수로 호출되는 경우 즉 위의 조건 없이 호출되는 경우 `this`는 전역 객체입니다. 브라우저에서는 `window` 객체입니다. 엄격 모드(`'use strict'`) 일 경우 `this`는 전역 객체 대신 `undefined`가 됩니다.
5.  위의 규칙 중 다수가 적용되면 더 높은 규칙이 승리하고 `this`값을 설정합니다.
6.  함수가 ES2015 화살표 함수인 경우 위의 모든 규칙을 무시하고 생성된 시점에서 주변 스코프의 `this`값을 받습니다.

상세한 설명은 [Medium 의 글](https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3)를 참조하세요.

###### 참고자료

* <https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3>
* <https://stackoverflow.com/a/3127440/1751946>

### 프로토타입 상속이 어떻게 작동하는지 설명하세요.

이것은 매우 일반적인 JavaScript 인터뷰 질문입니다. 모든 JavaScript 객체는 다른 객체에 대한 참조인 `prototype` 프로퍼티를 가지고 있습니다. 객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 JavaScript 엔진은 객체의 `prototype`과 `prototype`의 `prototype`등을 보고 프로퍼티가 정의될 때까지 찾고 만약 객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 프로토타입 체인 중 하나에 있거나 프로토타입 체인의 끝에 도달할 때까지 찾습니다. 이 동작은 고전적인 상속을 흉내 내지만 실제로 [상속보다 위임](https://davidwalsh.name/javascript-objects)에 더 가깝습니다.

###### 참고자료

* <https://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpson>
* <https://davidwalsh.name/javascript-objects>

### AMD 대 CommonJS 에 대해 어떻게 생각하십니까?

두 가지 모두 ES2015 가 등장할 때까지 JavaScript 에 기본적으로 존재하지 않는 모듈 시스템을 구현하는 방법입니다. CommonJS 는 동기식인 반면 AMD (Asynchronous Module Definition - 비동기식 모듈 정의)는 분명히 비동기식입니다. CommonJS 는 서버-사이드 개발을 염두에 두고 설계되었으며 AMD 는 모듈의 비동기 로딩을 지원하므로 브라우저용으로 더 많이 사용됩니다.

AMD 은 구문이 매우 장황하고 CommonJS 은 다른 언어로 된 import 문을 작성하는 스타일에 더 가깝습니다. 대부분의 경우 AMD 를 필요로 하지 않습니다. 모든 JavaScript 를 연결된 하나의 번들 파일로 제공하면 비동기 로딩 속성의 이점을 누릴 수 없기 때문입니다. 또한 CommonJS 구문은 모듈 작성의 노드 스타일에 가깝고 클라이언트-사이드와 서버-사이드 JavaScript 개발 사이를 전환할 때 문맥 전환 오버 헤드가 적습니다.

ES2015 모듈이 동기식 및 비동기식 로딩을 모두 지원하는 것이 반가운 것은 마침내 하나의 접근 방식만 고수할 수 있다는 점입니다. 브라우저와 노드에서 완전히 작동되지는 않았지만 언제나 트랜스파일러를 사용하여 코드를 변환할 수 있습니다.

###### 참고자료

* <https://auth0.com/blog/javascript-module-systems-showdown/>
* <https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs>

### IIFE 즉시실행함수
`(function foo(){ })()` 그리고 `(function foo(){ }())`로 쓰입니다. 
IIFE(즉시 호출 함수 표현식)이라고도 하고, 모듈 패턴이라고도 하는데, 함수를 선언하자마자 바로 실행시켜버리는 거죠. 함수를 function() {}로 선언하면서 동시에 ()를 붙이니까 즉시 실행됩니다. 이 구문이 라이브러리를 만들 때 기본입니다. 많은 라이브러리가 이 구문을 활용하고 있습니다. 비공개 변수가 없는 자바스크립트에 비공개 변수 기능을 만들어주기 때문이죠. 이 패턴은 꼭 기억하고 있어야합니다!
본문 내에서 자체를 참조할 필요가 없는 경우 해당 함수의 이름을 생략할 수도 있습니다.

###### 참고자료

* <http://lucybain.com/blog/2014/immediately-invoked-function-expression/>

### `null`, `undefined`, `선언되지 않은 변수` 의 차이점은 무엇입니까? 당신은 어떻게 이 상태들에 대한 점검을 할 것입니까?

**선언되지 않은 변수** 변수는 이전에 `var`, `let`, `const` 를 사용하여 생성되지 않은 식별자에 값을 할당할 때 생성됩니다. `선언되지 않은 변수` 는 현재 범위 외부에서 전역으로 정의됩니다. strict 모드에서는 `선언되지 않은 변수` 에 할당하려고 할 때 `ReferenceError` 가 throw 됩니다. `선언되지 않은 변수` 는 전역 변수처럼 좋지 않은 것입니다. 그것들은 모두 피하세요! 이들을 검사하기 위해 사용할 때 `try` / `catch` 블록에 감싸십시오.

```js
function foo() {
  x = 1; // strict 모드에서 ReferenceError를 발생시킵니다.
}

foo();
console.log(x); // 1
```

`undefined` 변수는 선언되었지만 값이 할당되지 않은 변수입니다. 이것은 `undefined` 타입입니다. 함수가 실행 결과에 따라 값을 반환하지 않으면 변수에 할당되며, 변수가 `undefined` 값을 갖습니다. 이것을 검사하기 위해, 엄격한 (`===`) 연산자 또는 `typeof` 에 `undefined` 문자열을 사용하여 비교하십시오. 확인을 위해 추상 동등 연산자(`==`)를 사용해서는 안되며, 이는 값이 `null` 이면 `true` 를 반환합니다.

```js
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === 'undefined'); // true

console.log(foo == null); // true. 옳지않습니다. 확인하는 데 사용하지 마세요.

function bar() {}
var baz = bar();
console.log(baz); // undefined
```

`null` 인 변수는 `null` 값에 명시적으로 할당될 것입니다. 그것은 값을 나타내지 않으며 명시적으로 할당된다는 점에서 `undefined`와 다릅니다. `null`을 체크하기 위해서 단순히 완전 항등 연산자(`===`)를 사용하여 비교하면 됩니다. 위와 같이, 추상 동등 연산자 (`==`)를 사용해서는 안되며, 값이 `undefined`이면 `true`를 반환합니다.

```js
var foo = null;
console.log(foo === null); // true

console.log(foo == undefined); // true. 옳지않습니다. 확인하는 데 사용하지 마세요.
```

개인적 습관으로, 저는 변수를 선언하지 않거나 할당하지 않은 상태로 두지 않습니다. 아직 사용하지 않으려는 경우, 선언한 후에 명시적으로 `null` 을 할당할 것입니다.

###### 참고자료

* <https://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variables>
* <https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined>

### 클로저는 무엇이며, 어떻게/왜 사용합니까?

클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. "렉시컬"은 렉시컬 범위 지정이 변수가 사용 가능한 위치를 결정하기 위해 소스 코드 내에서 변수가 선언된 위치를 사용한다는 사실을 나타냅니다. 클로저는 외부 함수가 반환된 후에도 외부 함수의 변수 범위 체인에 접근할 수 있는 함수입니다.

**왜 클로저를 사용합니까?**

* 데이터 프라이버시 / 클로저로 private method 를 모방. 일반적으로 [모듈 패턴](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript)에 사용됩니다.
* [부분적인 응용 프로그램 또는 currying](https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8#.l4b6l1i3x).

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures>
* <https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36>

### `.forEach` 루프와 `.map()` 루프 사이의 주요 차이점을 설명할 수 있습니까? 왜 둘 중 하나를 선택하겠습니까?

이 두 함수의 차이점을 이해하기 위해 각 함수가 무엇을 하는지 살펴보겠습니다.

**`forEach`**

* 배열의 요소를 반복합니다.
* 각 요소에 대한 콜백을 실행합니다.
* 값을 반환하지 않습니다.

```js
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
  // num 및 / 또는 index로 무엇이든 해보세요.
});

// doubled = undefined
```

**`map`**

* 배열의 요소를 반복합니다.
* 각 요소에서 함수를 호출하여 결과로 새 배열을 작성하여 각 요소를 새 요소에 매핑합니다.

```js
const a = [1, 2, 3];
const doubled = a.map(num => {
  return num * 2;
});

// doubled = [2, 4, 6]
```

`.forEach` 와 `.map()` 의 주된 차이점은 `.map()` 이 새로운 배열을 반환한다는 것입니다. 결과가 필요하지만 원본 배열을 변경하고 싶지 않으면 `.map()` 이 확실한 선택입니다. 단순히 배열을 반복할 필요가 있다면, forEach 가 좋은 선택입니다.

###### 참고자료

* <https://codeburst.io/javascript-map-vs-foreach-f38111822c0f>

### 익명 함수의 일반적인 사용 사례는 무엇입니까?

익명함수는 IIFE 로 사용되어 지역 범위 내에서 일부 코드를 캡슐화하므로 선언된 변수가 전역 범위로 누출되지 않습니다.

```js
(function() {
  // 몇몇 코드
})();
```

한 번 사용되며 다른 곳에서는 사용할 필요가 없는 콜백으로 사용됩니다. 함수 본체를 찾기 위해 다른 곳을 찾아볼 필요 없이 코드를 호출하는 코드 바로 안에 핸들러가 정의되어 있으면 코드가 보다 독립적이고 읽기 쉽게 보일 것입니다.

```js
setTimeout(function() {
  console.log('Hello world!');
}, 1000);
```

함수형 프로그래밍 또는 Lodash 에 대한 인수(콜백과 유사).

```js
const arr = [1, 2, 3];
const double = arr.map(function(el) {
  return el * 2;
});
console.log(double); // [2, 4, 6]
```

###### 참고자료

* <https://www.quora.com/What-is-a-typical-usecase-for-anonymous-functions>
* <https://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo>

### 코드를 어떻게 구성합니까? (모듈 패턴, 고전적인 상속?)

과거에는 Backbone 모델을 만들고 그 모델에 메소드를 연결하는 등 OOP 접근 방식을 장려하는 모델에 Backbone 을 사용했습니다.

모듈 패턴은 여전히​​ 훌륭하지만, 요즘에는 React/Redux 기반의 Flux 아키텍처를 사용합니다. 이 아키텍처는 단방향 프로그래밍 방식을 권장합니다. 저는 평범한 객체를 사용하여 응용 프로그램의 모델을 표현하고 이러한 객체를 조작하는 유틸리티 순수 함수를 작성합니다. 상태는 다른 Redux 응용 프로그램에서와 마찬가지로 action 및 reducer 를 사용하여 조작됩니다.

가능한 경우 고전적인 상속을 사용하지 않습니다. 저는 [이 규칙들](https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4)을 유지합니다.

### 호스트 객체와 내장 객체의 차이점은 무엇입니까?

내장 객체는 ECMAScript 사양에 정의된 JavaScript 언어의 일부인 객체입니다. (예: `String`, `Math`, `RegExp`, `Object`, `Function` 등)

호스트 객체는 `window`, `XMLHTTPRequest` 등과 같이 런타임 환경 (브라우저 또는 노드)에 의해 제공됩니다.

###### 참고자료

* <https://stackoverflow.com/questions/7614317/what-is-the-difference-between-native-objects-and-host-objects>

### `Person(){}`, `var person = Person()`, `var person = new Person()` 의 차이점은 무엇입니까?

이 질문은 굉장해 애매합니다. 질문의 의도에 대한 저의 최선의 추측은 JavaScript의 생성자에 대해 묻는 것입니다. 엄밀히 말하면, `function Person(){}`은 정상적인 함수 선언일 뿐입니다. 이 컨벤션은 생성자로 사용하기 위해 함수에 PascalCase 를 사용합니다.

`var person = Person()`은 생성자가 아니며 `Person`을 함수로 호출합니다. 함수를 생성자로 사용하려는 경우에 이렇게 호출하는 것이 일반적인 실수입니다. 일반적으로 생성자는 아무것도 반환하지 않으므로 일반 함수처럼 생성자를 호출하면 `undefined`가 반환되고 지정된 변수에 할당됩니다.

`var person = new Person()`은 `Person.prototype`을 상속받은 `new` 연산자를 사용하여 `Person` 객체의 인스턴스를 생성합니다. 또 다른 방법은 `Object.create`를 사용하는 것입니다: `Object.create(Person.prototype)`.

```js
function Person(name) {
  this.name = name;
}

var person = Person('John');
console.log(person); // undefined
console.log(person.name); // Uncaught TypeError: 정의되지 않은 'name' 프로퍼티를 읽을 수 없습니다

var person = new Person('John');
console.log(person); // Person { name: "John" }
console.log(person.name); // "john"
```

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new>

### `.call`과 `.apply`의 차이점은 무엇입니까?

`.call`과 `.apply`는 모두 함수를 호출하는데 사용되며 첫 번째 매개 변수는 함수 내에서 `this`의 값으로 사용됩니다. 그러나 `.call`은 쉼표로 구분된 인수를 두 번째 인수로 취하고 `.apply`는 인수의 배열을 두 번째 인수로 취합니다. `call`은 `C`: `Comma` 로 구분되며 `apply`는 인수 배열인 `A`: `arguments` 라고 기억하면 쉽습니다.

```js
function add(a, b) {
  return a + b;
}

console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3
```

call 의쓰임
```
function greet() {
  var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');
  console.log(reply);
}

var obj = {
  animal: 'cats', sleepDuration: '12 and 16 hours'
};

greet.call(obj);  // cats typically sleep between 12 and 16 hours
```
greet의 this는 obj를 가리키게 된다. 
The call() allows for a function/method belonging to one object to be assigned and called for a different object.
call() provides a new value of this to the function/method. With call, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.
bind
원하는 Function 에 인자로 넘긴 this 가 바인딩 된 새로운 함수를 리턴한다
this의 값을 바꿀 수 있는 마지막 함수는 bind이다. bind를 사용하면 함수의 this 값을 영구히 바꿀 수 있다. update 메서드를 이리저리 옮기면서 호출할 때 this 값은 항상 bruce가 되게끔, call이나 apply, 다른 bind와 함께 호출하더라도 this 값이 bruce가 되도록 하려면 bind를 사용한다. 
 
slice의 default parameters, slice는 인자가 
아무것도 없으면 this를 배열로 만들어 준다. 이를 call을 이용해서 default parameter을 만들어줄 수 있다. 
```
function list() {
    return Array.prototype.slice.call(arguments);
}
var list1 = list(1, 2, 3);
var leadingThirtysevenList = list.bind(undefined, 37);
var list2 = leadingThirtysevenList(); // [37]
var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]
```
bind : setTimeout
setTimeout 의 callback 의 this 는 전역 컨텍스트에서 사용되므로 window 또는 global(Node.js) 이다. 따라서 setTimeout 의 callback 으로 오브젝트의 메소드를 주고, 그 메소드 내에서 오브젝트의 인스턴스를 this 로 참조하려면, bind가 꼭 필요하다.

## 콜백이라? 화살표함수로 블록스코프의 성질을가지는 건? 
```
function LateBloomer() {
    this.petalCount = Math.ceil(Math.random() * 12) + 1;
}
LateBloomer.prototype.bloom = function () {
    window.setTimeout(this.declare.bind(this), 1000);
};
LateBloomer.prototype.declare = function () {
    console.log('I am a beautiful flower with ' + this.petalCount + ' petals!');
};
``` 
### Feature detection, Feature inference, UA String 의 차이점은 무엇입니까?

**Feature Detection**

Feature Detection은 브라우저가 특정 코드 블록을 지원하는지에 따라 다른 코드를 실행하도록 하여, 일부 브라우저에서 항상 오류가 발생하도록 합니다. 예:

```js
if ('geolocation' in navigator) {
  // navigator.geolocation를 사용할 수 있습니다
} else {
  // 부족한 기능 핸들링
}
```

[Modernizr](https://modernizr.com/)는 Feature detection을 처리 ​​할 수 있는 훌륭한 라이브러리입니다.
https://webdir.tistory.com/82

**Feature Inference**

Feature inference는 Feature detection과 마찬가지로 기능을 확인하지만 다른 함수도 존재한다고 가정하고 사용합니다. 예:

```js
if (document.getElementsByTagName) {
  element = document.getElementById(id);
}
```

이것은 권장하지 않습니다. Feature detection이 더 확실합니다.

**UA String**

네트워크 프로토콜 피어가 요청하는 소프트웨어 사용자 에이전트의 응용 프로그램 유형, 운영 체제, 소프트웨어 공급 업체 또는 소프트웨어 버전을 식별할 수 있도록 해주는 browser-reported String입니다. `navigator.userAgent` 를 통해 접근 할 수 있습니다. 하지만 문자열은 구문 분석하기 까다로우며 스푸핑 될 수 있습니다. 예를 들어 Chrome은 Chrome과 Safari로 모두 보고됩니다. Safari를 감지하기 위해서는 Safari 문자열이 있는지와 Chrome 문자열이 없는지 확인해야 합니다. 이 방법은 사용하지 마십시오.

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection>
* <https://stackoverflow.com/questions/20104930/whats-the-difference-between-feature-detection-feature-inference-and-using-th>
* <https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent>


### JSONP의 작동 방식(Ajax가 아닌 방법)을 설명하십시오.

JSONP (JSON with Padding)은 현재 페이지에서 cross-origin 도메인으로의 Ajax 요청이 허용되지 않기 때문에 웹 브라우저에서 cross-domain 정책을 우회하는 데 일반적으로 사용되는 방법입니다.

JSONP는 `<script>`태그를 통해 cross-origin 도메인에 요청하고 보통 `callback`쿼리 매개 변수(예: `https://example.com?callback=printData`)로 요청합니다. 그러면 서버는 `printData`라는 함수 안에 데이터를 래핑하여 클라이언트로 반환합니다.

```html
<!-- https://mydomain.com -->
<script>
function printData(data) {
  console.log(`My name is ${data.name}!`);
}
</script>

<script src="https://example.com?callback=printData"></script>
```

```js
// https://example.com?callback=printData 에서 로드된 파일
printData({ name: 'Yang Shun' });
```

클라이언트는 전역 범위에 있는 `printData` 함수를 가져야만 하고 cross-origin domain으로부터의 응답이 수신될 때 함수가 클라이언트에 의해 실행됩니다.

JSONP는 안전하지 않을 수 있으며 보안과 관련이 있습니다. JSONP은 실제로 JavaScript고, JavaScript가 할 수 있는 모든 작업을 수행할 수 있으므로 JSONP 데이터 공급자를 신뢰해야만 합니다.

요즘에는 [CORS](http://en.wikipedia.org/wiki/Cross-origin_resource_sharing)가 권장되는 접근 방식이며 JSONP는 해킹으로 간주됩니다.
 
### "attribute"와 "property"의 차이점은 무엇입니까?

attribute 속성은 HTML 마크업에 정의되지만 property 속성은 DOM에 정의됩니다. 차이점을 설명하기 위해 HTML에 이 텍스트 필드가 있다고 세요. `<input type="text" value="Hello">`.

```js
const input = document.querySelector('input');
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello
```

그러나 텍스트 필드에 "World!"를 추가하면 이렇게 될것입니다.

```js
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
```

###### 참고자료

* <https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html>

### 내장 JavaScript 객체를 확장하는 것이 좋은 생각이 아닌 이유는 무엇입니까?

빌트인/네이티브 JavaScript 객체를 확장한다는 것은 prototype에 속성/함수를 추가한다는 것을 의미합니다. 이것은 처음에는 좋은 생각처럼 보일 수 있지만 실제로는 위험합니다. 여러분의 코드가 동일한 `contains` 메소드를 추가함으로써 `Array.prototype`을 확장하는 여러가지 라이브러리를 사용한다고 상상해보십시오. 이러한 구현은 메소드를 서로 덮어쓰게 되며 이 두 메소드의 동작이 동일하지 않으면 코드가 망가질 것입니다.

네이티브 객체를 확장할 수 있는 유일한 경우는 polyfill을 만들려고 할 때입니다. JavaScript 사양의 일부이지만 오래된 브라우저이기 때문에 사용자 브라우저에 없을 수도 있는 메서드에 대한 고유한 구현을 제공해야 할 경우입니다.

### polyfill
 Polyfill을 찾아봅니다. 구글에서 ‘polyfill promise’ 라고 검색하면 여러가지 대안을 찾을 수 있습니다. (폴리필:폴리필(polyfill)은 개발자가 특정 기능이 지원되지 않는 브라우저를 위해 사용할 수 있는 코드 조각이나 플러그인을 말한다.)

###### 참고자료

* <http://lucybain.com/blog/2014/js-extending-built-in-objects/>

### document `load` 이벤트와 document `DOMContentLoaded` 이벤트의 차이점은 무엇입니까?

`DOMContentLoaded` 이벤트는 스타일시트, 이미지, 서브프레임이 로딩을 기다리지 않고 초기 HTML 문서가 완전히 로드되고 파싱될 때 발생합니다.

`window`의 `load`이벤트는 DOM과 모든 종속 리소스와 에셋들이 로드된 후에 만 ​​발생합니다.

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded>
* <https://developer.mozilla.org/en-US/docs/Web/Events/load>

### `==`와 `===`의 차이점은 무엇입니까?

`==`는 추상 동등 연산자이고 `===`는 완전 동등 연산자입니다. `==`연산자는 타입 변환이 필요한 경우 타입 변환을 한 후에 동등한지 비교할 것입니다. `===`연산자는 타입 변환을 하지 않으므로 두 값이 같은 타입이 아닌 경우 `===`는 단순히 `false`를 반환합니다. `==`를 사용하면 다음과 같은 무서운 일이 발생할 수 있습니다.

```js
1 == '1'; // true
1 == [1]; // true
1 == true; // true
0 == ''; // true
0 == '0'; // true
0 == false; // true
```

저의 조언은 편의상 `null`과 `undefined`를 비교할 때를 제외하고, `==`연산자를 절대 사용하지 않는 것입니다. `a == null`은 `a`가 `null` 또는 `undefined`이면 `true`를 반환합니다.

```js
var a = null;
console.log(a == null); // true
console.log(a == undefined); // true
```
 
###### 참고자료

* <https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator>

### `"use strict";` 이 무엇입니까? 사용시 장단점이 무엇인가요?

'use strict'는 전체 스크립트나 개별 함수에 엄격 모드를 사용하는데 사용되는 명령문입니다. Strict 모드는 JavaScript 제한된 변형에서 선택하는 방법입니다.

장점:

* 실수로 전역변수를 만드는 것이 불가능합니다.
* 암묵적으로 실패한 예외를 throw하지 못하는 할당을 만듭니다.
* 삭제할 수 없는 속성을 삭제하려고 시도합니다. (시도 효과가 없을 때까지)
* 함수의 매개변수 이름은 고유해야합니다.
* `this`는 전역 컨텍스트에서 undefined입니다.
* 예외를 발생시키는 몇 가지 일반적인 코딩을 잡아냅니다.
* 헷갈리거나 잘 모르는 기능을 사용할 수 없게 합니다.

단점 :

* 일부 개발자는 익숙하지 않은 기능이 많습니다.
* `function.caller`와 `function.arguments`에 더 이상 접근할 수 없습니다.
* 서로 다른 엄격한 모드로 작성된 스크립트를 병합하면 문제가 발생할 수 있습니다.

전반적으로 장점이 단점보다 중요하다고 생각합니다. 엄격 모드가 차단하는 기능에 의존하지 않아도 됩니다. 엄격한 모드를 사용하는 것을 추천합니다.
 
 
 모든 스크립트는 전역 스코프에 접근할 수 있으며 모든 사람이 전역 네임스페이스를 사용하여 변수를 정의하면 충돌이 발생할 수 있습니다. 모듈 패턴 (IIFEs)을 사용하여 변수를 로컬 네임스페이스 내에 캡슐화하십시오.

### 왜 `load` 이벤트와 같은 것을 사용하나요? 이 이벤트에는 단점이 있나요? 다른 대안을 알고 있나요? 알고 있다면 왜 그것을 사용할 건가요?

`load` 이벤트는 문서로딩 프로세스가 끝날 때 발생됩니다. 이 시점에서 문서의 모든 객체가 DOM에 있고, 모든 이미지, 스크립트, 링크 및 하위 프레임로딩이 완료됩니다.

DOM 이벤트 `DOMContentLoaded`는 페이지의 DOM이 생성된 후에 발생하지만 다른 리소스가 로딩되기를 기다리지 않습니다. 이것은 초기화되기 전에 전체 페이지가 로드될 필요가 없는 경우에 선호됩니다.

TODO.

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload>

### single page app이 무엇인지 설명하고 SEO-friendly한 앱을 만드는 방법을 설명하십시오.

아래는 [Grab Front End Guide](https://github.com/grab/front-end-guide)에서 가져온 것이며, 우연히도 저를 위해 쓰였습니다!

웹 개발자는 요즘 웹 사이트가 아닌 웹 앱으로 제작한 제품을 언급합니다. 두 가지 용어 사이에는 엄격한 차이는 없지만 웹 앱은 대화형 및 동적인 경향이 있어 사용자가 작업을 수행하고 작업에 대한 응답을 받을 수 있습니다. 전통적으로, 브라우저는 서버에서 HTML을 받아 렌더링합니다. 사용자가 다른 URL로 이동하면 전체페이지 새로고침이 필요하며 서버는 새페이지에 대해 새 HTML을 보냅니다. 이를 server-side rendering이라고합니다.

그러나 현대 SPA에서는 대신 클라이언트 측 렌더링이 사용됩니다. 브라우저는 전체 애플리케이션에 필요한 스크립트(프레임워크, 라이브러리, 앱 코드) 및 스타일시트와 함께 서버의 초기 페이지를 로드합니다. 사용자가 다른 페이지로 이동하면 페이지 새로고침이 발생하지 않습니다. 페이지의 URL은 [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)를 통해 업데이트됩니다. 일반적으로 JSON 형식의 새 페이지에 필요한 새 데이터는 브라우저에서 [AJAX](https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started) 요청을 통해 서버로 전송됩니다. SPA는 초기 페이지 로딩에서 미리 다운로드된 JavaScript를 통해 페이지를 동적으로 업데이트합니다. 이 모델은 네이티브 모바일 앱의 작동 방식과 유사합니다.
### NUXT

장점들:

* 전체 페이지 새로고침으로 인해 페이지 탐색 사이에 하얀 화면이 보이지 않아 앱이 더 반응적으로 느껴지게 됩니다.

* 동일한 애셋을 페이지 로드마다 다시 다운로드할 필요가 없으므로 서버에 대한 HTTP 요청이 줄어듭니다.

* 클라이언트와 서버 사이의 고려해야 할 부분을 명확하게 구분합니다. 서버 코드를 수정하지 않고도 다양한 플랫폼(예: 모바일, 채팅 봇, 스마트워치)에 맞는 새로운 클라이언트를 쉽게 구축할 수 있습니다. 또한 API 계약이 깨지지 않는 한 내에서 클라이언트와 서버에서 기술 스택을 독립적으로 수정할 수 있습니다.

단점들:

* 여러 페이지에 필요한 프레임워크, 앱 코드, 애셋로드로 인해 초기 페이지로드가 무거워집니다.

* 모든 요청을 단일 진입점으로 라우트하고 클라이언트 측 라우팅이 그 한곳에서 인계받을 수 있도록 서버를 구성하는 추가 단계가 수행되어야합니다.

* SPA는 콘텐츠를 렌더링하기 위해 JavaScript에 의존하지만 모든 검색 엔진이 크롤링 중에 JavaScript를 실행하지는 않으며 페이지에 빈 콘텐츠가 표시될 수 있습니다. 이로 인해 의도치 않게 앱의 검색 엔진 최적화 (SEO)가 어려워집니다.

그러나 대부분의 경우 앱을 제작할 때 검색 엔진에서 모든 콘텐츠 색인할 필요는 없으므로 SEO가 가장 중요한 요소는 아닙니다. 이를 극복하기 위해, 앱을 서버 측 렌더링하거나 [Prerender](https://prerender.io/)와 같은 서비스를 사용하여 "브라우저에서 JavaScript를 렌더링하고, 정적 HTML을 저장한 다음, 크롤러에게 반환합니다".

###### 참고자료

* <https://github.com/grab/front-end-guide#single-page-apps-spas>
* <http://stackoverflow.com/questions/21862054/single-page-app-advantages-and-disadvantages>
* <http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/>
* <https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52>




### JavaScript로 컴파일되는 언어로 JavaScript 코드를 작성하는 경우의 장단점은 무엇입니까?

JavaScript로 컴파일되는 언어의 예로 CoffeeScript, Elm, ClojureScript, PureScript 및 TypeScript가 있습니다.

장점:

* JavaScript의 오랜 문제점들을 수정하고 JavaScript 안티-패턴을 방지합니다.
* JavaScript 위에 syntatic sugar를 제공함으로써 더 짧은 소스코드를 작성할 수 있도록 해줍니다. 제 생각에는 ES5는 부족하지만 ES2015는 굉장합니다.
* 정적 타입은 시간 경과에 따라 유지 관리해야 하는 대규모 프로젝트에 대해 훌륭합니다(TypeScript의 경우).

단점:

* 브라우저는 오직 JavaScript만 실행하기 때문에 빌드/컴파일 프로세스가 필요하며 브라우저에 제공되기 전에 JavaScript로 코드를 컴파일해야 합니다.
* 소스 맵이 미리 컴파일된 소스에 잘 매핑되지 않으면 디버깅이 어려울 수 있습니다.
* 대부분의 개발자들은 이러한 언어에 익숙하지 않으므로 이를 배워야합니다. 프로젝트에 사용할 경우 팀의 비용이 증가합니다.
* 소규모 커뮤니티 (언어에 따라 다름)는 리소스, 자습서, 라이브러리 및 툴링을 찾기가 어려울 수 있음을 의미합니다.
* IDE / 편집기 지원이 부족할 수 있습니다.
* 이러한 언어는 항상 최신 JavaScript 표준보다 뒤처집니다.
* 개발자들은 자신들의 코드를 무엇으로 컴파일하고 있는지 알고 있어야 합니다. 왜냐하면 그것이 실제로 실행될 것이고 결국에는 중요한 것이기 때문입니다.

실질적으로 ES2015는 JavaScript를 크게 개선하여 작성하기가 훨씬 쉬워졌습니다. 요즘은 CoffeeScript가 필요하지 않습니다.

###### 참고자료

* <https://softwareengineering.stackexchange.com/questions/72569/what-are-the-pros-and-cons-of-coffeescript>

### JavaScript 코드를 디버깅하기 위해 어떤 도구와 기술을 사용하십니까?

* React and Redux
  * [React Devtools](https://github.com/facebook/react-devtools)
  * [Redux Devtools](https://github.com/gaearon/redux-devtools)
* JavaScript
  * [Chrome Devtools](https://hackernoon.com/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d)
  * `debugger` statement
  * Good old `console.log` debugging

###### 참고자료

* <https://hackernoon.com/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d>
* <https://raygun.com/blog/javascript-debugging/>

### 오브젝트 속성 및 배열 항목을 반복할 때 사용하는 언어 구조는 무엇입니까?

오브젝트의 경우:

* `for` 반복문 - `for (var property in obj) { console.log(property); }`. 그러나 이것은 상속된 속성도 반복되며, 사용하기 전에 `obj.hasOwnProperty(property)` 체크를 추가해야 합니다.
* `Object.keys()` - `Object.keys(obj).forEach(function (property) { ... })`. 
`Object.keys ()`는 전달하는 객체의 열거 가능한 모든 속성을 나열하는 정적 메서드입니다.
* `Object.getOwnPropertyNames()` - `Object.getOwnPropertyNames(obj).forEach(function (property) { ... })`. `Object.getOwnPropertyNames()`는 전달하는 객체의 열거 가능한 속성과 열거되지 않는 모든 속성을 나열하는 정적 메서드입니다. 

### 변경 가능 객체와 변경 불가능 객체 간의 차이점을 설명하십시오.

* JavaScript에서 불변 객체의 예는 무엇입니까?
* 불변성의 장점과 단점은 무엇입니까?
* 자신의 코드에서 어떻게 불변성을 얻을 수 있습니까?

### IMMUTABLE
TODO

### 동기 및 비동기 함수의 차이점을 설명하십시오.

동기 함수는 차단되는 반면 비동기 함수는 차단되지 않습니다. 동기 함수에서는 다음 명령문이 실행되기 전에 명령문이 완료됩니다. 이 경우 프로그램은 명령문의 순서대로 정확하게 평가되고 명령문 중 하나가 매우 오랜 시간이 걸리면 프로그램 실행이 일시 중지됩니다.

비동기 함수는 일반적으로 파라미터를 통해서 콜백을 받아들이고 비동기 기능은 일반적으로 매개 변수로 콜백을 허용하며 비동기 기능이 호출된 후 즉시 다음 줄에서 실행이 계속됩니다. 콜백은 비동기 작업이 완료되고 호출 스택이 비어 있을 때만 호출됩니다. 웹 서버에서 데이터를 로드하거나 데이터베이스를 쿼리 하는 등의 엄격한 작업을 비동기식으로 수행하여 주 스레드가 긴 작업을 완료할 때까지 차단하지 않고 다른 작업을 계속해야 합니다(브라우저의 경우 UI가 중지됨).

### 이벤트 루프란 무엇입니까? 콜 스택과 태스크 큐의 차이점은 무엇입니까?

이벤트 루프는 콜 스택을 모니터하고 태스크 큐에서 수행할 작업이 있는지 확인하는 단일 스레드 루프입니다. 콜 스택이 비어 있고 태스크 큐에 콜백 함수가 있는 경우, 함수는 큐에서 제외되고 실행될 콜 스택으로 푸시됩니다.

Philip Robert의 [talk on the Event Loop](https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html)를 아직 확인하지 않은 경우 확인하십시오. JavaScript에서 가장 많이 본 동영상 중 하나입니다. 
**함수 선언**

```js
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
```

**함수 표현**

```js
foo(); // Uncaught TypeError: foo는 함수가 아닙니다
var foo = function() {
  console.log('FOOOOO');
};
```

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function>

### `let`, `var` 또는 `const`를 사용하여 생성된 변수들의 차이점은 무엇인가요?

`var` 키워드를 사용하여 선언된 변수는 함수가 생성된 함수나 함수 밖에서 생성 된 함수에 전역 오브젝트로 적용됩니다. `let`과 `const` 블록 범위입니다. 즉, 가장 가까운 중괄호(function, if-else 블록 또는 for-loop) 내에서만 접근할 수 있습니다.

```js
function foo() {
  // 함수 내에서 모든 변수에 접근할 수 있습니다.
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';

  console.log(bar); // "bar"
  console.log(baz); // "baz"
  console.log(qux); // "qux"
}

console.log(bar); // ReferenceError: bar가 정의되지 않았습니다
console.log(baz); // ReferenceError: baz가 정의되지 않았습니다
console.log(qux); // ReferenceError: qux가 정의되지 않았습니다
```

```js
if (true) {
  var bar = 'bar';
  let baz = 'baz';
  const qux = 'qux';
}

// var로 선언된 변수는 함수 스코프의 어디에서나 접근할 수 있습니다.
console.log(bar); // "bar"
// let과 const로 정의된 변수는 정의된 블록 외부에서 접근할 수 없습니다.
console.log(baz); // ReferenceError: baz가 정의되지 않았습니다
console.log(qux); // ReferenceError: qux가 정의되지 않았습니다
```

`var`는 변수가 올라가도록 허용합니다. 즉, 변수가 선언되기 전에 코드에서 참조 될 수 있습니다. `let`과 `const`는 이것을 허락하지 않고 대신 에러를 던집니다.

```js
console.log(foo); // undefined

var foo = 'foo';

console.log(baz); // ReferenceError: 초기화 전에 렉시컬 선언 `baz`에 접근할 수 없습니다.

let baz = 'baz';

console.log(bar); // ReferenceError: 초기화 전에 렉시컬 선언 `bar`에 접근할 수 없습니다.

const bar = 'bar';
```

`var`을 사용하여 변수를 다시 선언해도 오류는 발생하지 않지만 'let'과 'const'는 오류를 발생시킵니다.

```js
var foo = 'foo';
var foo = 'bar';
console.log(foo); // "bar"

let baz = 'baz';
let baz = 'qux'; // SyntaxError: let baz의 재선언
```

`let`은 변수의 값을 재할당 할 수 있지만 `const`는 재할당 할 수 없다는 점이 다릅니다.

```js
// 괜찮습니다
let foo = 'foo';
foo = 'bar';

// 예외가 발생합니다
const baz = 'baz';
baz = 'qux';
```

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let>
* <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var>
* <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const>

### ES6 클래스와 ES5 함수 생성자의 차이점은 무엇입니까?

먼저 각각의 예를 살펴 보겠습니다.

```js
// ES5 함수 생성자
function Person(name) {
  this.name = name;
}

// ES6 클래스
class Person {
  constructor(name) {
    this.name = name;
  }
}
```

간단한 생성자의 경우에는 매우 유사합니다.

생성자의 주요 차이점은 상속을 사용할 때 발생합니다. `Person`의 하위 클래스이면서 `studentId` 필드를 추가로 가지고 있는 `Student` 클래스를 만들고자 한다면, 이것이 우리가 위에 추가해서 해야 할 일입니다.

```js
// ES5 함수 생성자
function Student(name, studentId) {
  // 수퍼 클래스의 생성자를 호출하여 수퍼 클래스에서 상속된 멤버를 초기화합니다.
  Person.call(this, name);

  // 서브 클래스의 멤버를 초기화합니다.
  this.studentId = studentId;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

// ES6 클래스
class Student extends Person {
  constructor(name, studentId) {
    super(name);
    this.studentId = studentId;
  }
}
```

ES5에서 상속을 사용하는 것이 훨씬 더 상세하며 ES6 버전은 이해하고 기억하기가 더 쉽습니다.

###### 참고자료

* https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance
* https://eli.thegreenplace.net/2013/10/22/classical-inheritance-in-javascript-es5

### 새 화살표 => 함수 구문에 대한 사용 예시를 들 수 있습니까? 이 새로운 구문은 다른 함수와 어떻게 다릅니까?

TODO

### 생성자의 메서드에 화살표 구문을 사용하면 어떤 이점이 있습니까?

TODO

### 고차 함수의 정의는 무엇입니까?

고차 함수는 다른 함수를 매개 변수로 사용하여 일부 데이터에서 작동하거나 결과로 함수를 반환하는 함수입니다. 고차 함수는 반복적으로 수행되는 일부 연산을 추상화하기 위한 것입니다. 전형적인 예는 배열과 함수를 인수로 취하는 `map`입니다. `map`은 고차 함수를 사용하여 배열의 각 항목을 변환하고 변환 된 데이터로 새로운 배열을 반환합니다. JavaScript에서 흔히 볼 수 있는 다른 예로 `forEach`, `filter`, `reduce`가 있습니다. 다른 함수에서 함수를 반환하는 많은 사용 사례가 있기 때문에 고차 함수는 배열을 조작할 필요가 없습니다. `Array.prototype.bind`는 JavaScript에서 그러한 예시 중 하나입니다.
 
### 객체나 배열에 대한 디스트럭쳐링 예시를 들 수 있습니까?

디스트럭쳐링은 ES6에서 사용할 수 있는 표현식으로 개체 또는 배열의 값을 추출하여 다른 변수에 배치하는 간결하고 편리한 방법을 제공합니다.

**배열 디스트럭쳐링**

```js
// 변수 할당.
const foo = ['one', 'two', 'three'];

const [one, two, three] = foo;
console.log(one); // "one"
console.log(two); // "two"
console.log(three); // "three"
```

```js
// 변수 교환
let a = 1;
let b = 3;

[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1
```

**객체 디스트럭쳐링**

```js
// 변수 할당.
const o = { p: 42, q: true };
const { p, q } = o;

console.log(p); // 42
console.log(q); // true
```

###### 참고자료

* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
* https://ponyfoo.com/articles/es6-destructuring-in-depth


### ES6 템플릿 리터럴은 문자열을 생성하는 데 많은 유연성을 제공합니다. 이에 대한 예를 들 수 있습니까?

TODO

### curry 함수의 예를 들어 줄 수 있습니까? 이 구문은 어떤 이점을 가지고 있나요? 

currying은 둘 이상의 매개 변수가 있는 함수가 여러 함수로 분리된 패턴으로, 직렬로 호출하면 필요한 모든 매개 변수가 한 번에 하나씩 누적됩니다. 이 기술은 기능 스타일로 작성된 코드를 읽고 작성하기가 더 쉬워진 경우 유용할 수 있습니다. 함수를 currying하려면 하나의 함수로 시작한 다음 하나의 매개 변수를 취하는 일련의 함수로 분리해야 합니다.

```js
function curry(fn) {
  if (fn.length === 0) {
    return fn;
  }

  function _curried(depth, args) {
    return function(newArgument) {
      if (depth - 1 === 0) {
        return fn(...args, newArgument);
      }
      return _curried(depth - 1, [...args, newArgument]);
    };
  }

  return _curried(fn.length, []);
}

function add(a, b) {
  return a + b;
}

var curriedAdd = curry(add);
var addFive = curriedAdd(5);

var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
```

###### 참고자료

* <https://hackernoon.com/currying-in-js-d9ddc64f162e>

### 스프레드 구문을 사용할 때의 이점은 무엇이며 rest 구문과 다른 점은 무엇입니까?

ES6의 스프레드 구문은 함수적인 패러다임에서 코딩할 때 매우 유용합니다. 왜냐하면 `Object.create`, `slice` 또는 라이브러리 함수를 사용하지 않고도 배열이나 객체의 복사본을 쉽게 만들 수 있기 때문입니다. 이 언어 기능은 Redux 또는 RX.js를 사용하는 프로젝트에서 많이 사용됩니다. 

```js
function putDookieInAnyArray(arr) {
  return [...arr, 'dookie'];
}

var result = putDookieInAnyArray(['I', 'really', "don't", 'like']); // ["I", "really", "don't", "like", "dookie"]

var person = {
  name: 'Todd',
  age: 29
};

var copyOfTodd = { ...person };
```

ES6의 rest 구문은 함수에 전달할 임의의 수의 인수를 포함하는 약식을 제공합니다. 이는 데이터의 배열을 채우기보다는 데이터를 가져와서 배열로 채우는 스프레드 구문의 역순과 같으며 배열 및 객체 디스트럭쳐링 할당뿐만 아니라 함수 인수에서도 작동합니다.

```js
function addFiveToABunchOfNumbers(...numbers) {
  return numbers.map(x => x + 5);
}

var result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15]
```

###### 참고자료

* <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax>
* <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters>

### 파일 간에 코드를 공유하려면 어떻게 해야 합니까?

이것은 Javascript 환경에 따라 다릅니다. 

클라이언트(브라우저 환경)에서는 변수/함수가 전역 범위 (`window`)에 선언되어있는 한 모든 스크립트가 이를 참조할 수 있습니다. 또는, 보다 모듈형 접근 방식을 위해 Require2S를 통해 비동기 모듈 정의(AMD)를 이용합니다. 

서버(Node.js)에서 일반적인 방법은 CommanJS를 사용하는 것입니다. 각 파일은 모듈로 취급되며 변수와 함수를`module.exports` 객체에 첨부하여 내보낼 수 있습니다. 
 
ES2015에서는 AMD 및 commonJS를 모두 대체하기 위한 모듈 구문을 정의합니다. 이 기능은 브라우저 및 노드 환경 모두에서 지원됩니다 

###### 참고자료

* http://requirejs.org/docs/whyamd.html
* https://nodejs.org/docs/latest/api/modules.html
* http://2ality.com/2014/09/es6-modules-final.html

### 정적인 클래스 멤버를 만드는 것이 좋은 이유는 무엇입니까?

정적 클래스 멤버(속성/메서드)는 클래스의 특정 인스턴스에 연결되지 않으며 어떤 인스턴스가 이를 참조하는지에 관계없이 동일한 값을 가집니다. 정적 속성은 일반적으로 구성 변수이며 정적 메서드는 일반적으로 인스턴스의 상태에 의존하지 않는 순수 유틸리티 함수입니다. 

### 다른 답변들

* <http://flowerszhong.github.io/2013/11/20/javascript-questions.html>
