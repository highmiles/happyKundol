# 프론트엔드정리  
[자바스크립트 이벤트 루프 등 비동기 함수 과정](#자바스크립트-이벤트-루프-등-비동기-함수-과정)
[생성자메서드에 화살표구문을 사용하면 어떤 이점](#생성자메서드에-화살표구문을-사용하면-어떤-이점)
[SPA](#spa)
[Promise와 callback](#promise와-callback)
[불변객체](#불변객체)
[호이스팅](#호이스팅)
[클로저](#클로저)
[스코프체인](#스코프체인)
[렉시컬 환경](#렉시컬-환경)
[이벤트 캡처링 & 버블링](#이벤트-캡처링-&-버블링)
[call과 apply, bind](#call과-apply,-bind)
[이슈: 크로스도메인 (CORS)](#이슈:-크로스도메인-(cors))
[이슈: 여러언어 페이지](#이슈:-여러언어-페이지)
[이슈: 기능이 제한된 브라우저](#이슈:-기능이-제한된-브라우저)
[null, undefined, 선언되지 않은 변수 의 차이점](#null,-undefined,-선언되지-않은-변수-의-차이점)
[자바스크립트 원시 / 참조타입 & Number](#자바스크립트-원시-/-참조타입-&-number)
[호스트 객체와 내장 객체의 차이점](#호스트-객체와-내장-객체의-차이점)
[정적 클래스 멤버](#정적-클래스-멤버)
[실행 컨텍스트(Execution Context)](#실행-컨텍스트(execution-context))
[자바스크립트 최적화기법](#자바스크립트-최적화기법)
[Clean Code 최적화기법](#clean-code-최적화기법)
[가상요소선택자, 가상클래스 선택자(CSS Pseudo code)](#가상요소선택자,-가상클래스-선택자(css-pseudo-code))
[HTML5 & CSS최적화](#html5-&-css최적화)
[cookie, sessionStorage, localStorage 사이의 차이점](#cookie,-sessionstorage,-localstorage-사이의-차이점)
[이미지태그 srcset](#이미지태그-srcset)
[CSS 선택자 특이성](#css-선택자-특이성)
[컨테이닝박스(block)](#컨테이닝박스(block))
[Resetting과 Normalizing CSS 의 차이점](#resetting과-normalizing-css-의-차이점)
[float의 작동법](#float의-작동법)
[z-index의 작동법](#z-index의-작동법)
[inline 과 inline-block 그리고  block](#inline-과-inline-block-그리고--block)
[relative, fixed, absolute 와 static 요소의 차이점](#relative,-fixed,-absolute-와-static-요소의-차이점)
[@media 속성](#@media-속성)
[box-size : border-box](#box-size-:-border-box)
[콘텐츠 숨기는 방법](#콘텐츠-숨기는-방법)
[attribute와 property의 차이점](#attribute와-property의-차이점)
[CSS 전처리기 SASS](#css-전처리기-sass)
[document load 이벤트와 document DOMContentLoaded 이벤트의 차이점](#document-load-이벤트와-document-domcontentloaded-이벤트의-차이점)
[==와 ===의 차이점](#==와-===의-차이점)
[DOCTYPE](#doctype)
[http2](#http2)
[브라우저의 렌더링 과정](#브라우저의-렌더링-과정)
[DIP(Dependency Inversion Principle) : 의존 역전 원칙](#dip(dependency-inversion-principle)-:-의존-역전-원칙)
[브라우저렌더링 과정](#브라우저렌더링-과정)
[GPU 가속화](#gpu-가속화)
[리페인트 리플로우 감소](#리페인트-리플로우-감소)
[SEO](#seo)
[OOP 개념 / ES5 & ES6 Class 차이](#oop-개념-/-es5-&-es6-class-차이)
[AMP](#amp)
[PWA](#pwa)
[SVG](#svg)
[AMD와 CommonJS 차이](#amd와-commonjs-차이)
[Vanila JS](#vanila-js)
[JavaScript 코드디버깅](#javascript-코드디버깅)
[ES6 스펙](#es6-스펙)
[함수형 프로그래밍](#함수형-프로그래밍)
[docker](#docker)
[Redis](#redis)
[MongoDB](#mongodb)
[Node.js](#node.js)
[D3.js](#d3.js)

### RESTFUL API
웹에 있는 자원들을 HTTP를  활용하여 잘 전송하기 위한  간단한 인터페이스

자원만을 URL에는 표기 / 메소드만으로 표현 / 동사말고 명사만 / 확장자는 표시하지 않는다

앞서 말한 규칙들을 지키면 어느정도 REST하다는 것입니다. 하지만 실제로는 아래의 6가지의 특징들을 지켜줘야 합니다. HTTP의 기초적인 특징으로 인해 많은 것은 지켜지나 HATEOAS 등 지키기 힘든 특징들도 있습니다.  

1. Uniform Interface
HTTP 표준만을 따른다면 "어떠한" 기술이라도 사용이 가능한 인터페이스 스타일을 말합니다. 즉, HTTP + JSON 으로 REST API 를 구현했다면 모든 플랫폼에서 사용가능한 느슨한 형태의 구조인 것이죠. 

2. Stateless
이건 HTTP 자체가 Stateless이기 때문에 HTTP를 이용하는 것만으로도 충족이 됩니다. Session을 서버 쪽에 유지하지 않는다는 의미로 API서버는 세션같은 정보를 신경쓸 필요가 없어지며 그러므로 구현이 더 단순해지게 됩니다. 

3. Cacheable
HTTP 는 원래 웹에서 작동하는 캐싱이 됩니다. 새로고침을 하면 304가 뜨면서 원래 있던 js와 css 이미지등을 불러오는 것을 볼 수 있습니다. 

4. Self-descriptiveness
메시지 포맷만으로 직관적으로 이 메시지가 무엇을 의미하는지 알 수 있어야 합니다. 제일 어려운 특징 중 하나입니다. 대부분의 웹들이 이 조건을 충족시키지 못하고 있습니다. 
예를 들어, 
```
{
"name":큰돌
"love":somebody
}
```
 라고 하는 메시지가 있다고 합시다. 이 메시지로 이 메시지로 뭘 하려는지 감이 오시나요? 아닐겁니다. 이러한 "감을 잡는 것"을 해주어야 진정한 REST가 됩니다. 이를 해결하는 방법은 두가지 입니다.  
1. IANA에 미디어 타입을 등록합니다. 하지만 이는 매번 등록해야 하니 귀찮습니다.  
2. data를 정의할 때 이 data가 어떤 것을 정의하는 지 메뉴얼로 연결되는 link를 추가합니다. 
* 메세지 안에 data가 뭘 뜻하는지 설명해주어야 한다는 것입니다.  

5. Client-Server 구조
클라이언트와 서버가 서로 독립적인 구조를 가져야 합니다. 물론.. 이는 HTTP 를 통해 가능한 구조입니다. 서버에서 HTTP 표준만 지킨다면 웹에서는 그에 따른 화면이 잘 나타나게 됩니다.  서버는 그저 API를 제공하고 그 API에 맞는 비즈니스 로직을 처리하면 되는 것이죠. 마찬가지로 클라이언트에서는 HTTP 로 받는 로직만 잘 처리하면 되는 것입니다.

6.  HATEOAS 구조
마찬가지로 많이 지키지 않는 구조 입니다.  URL 에 따라 다른 페이지를 보여줘야 하는 것은 물론이며, 서버는 클라이언트 요청에 따른 URL RESPONSE를 보내야 합니다.  
```
// send person object with HATEOAS links added
res.json(personObject, [
    { rel: "self", method: "GET", href: 'http://127.0.0.1' },
    { rel: "create", method: "POST", title: 'Create Person', href: 'http://127.0.0.1/person' }
]);
```
### Ajax
AJAX: Asynchronous Javascript And XML, 에이젝스라 불리는 이 것을 직역하자면, 비동기 자바스크립트 그리고 XML을 뜻합니다. 이건 어떤 특정한 단일 기술을 뜻하는 용어는 아니며 여러가지 기술집합을 의미합니다. 넓은 의미의 AJAX는 웹 클라이언트 측에서 리로드 없이 비동기적으로 콘텐츠를 변경하기 위해 사용하는 모든 기술을 지칭하며, 좁은 의미의 AJAX는 서버측과 비동기적으로 통신하는 기술을 말합니다.     
동기적인 방식은 웹사이트에서 어떤 요청을 하면 그 요청을 수행하는 동안 사용자는 아무것도 못하는 것을 말합니다. 
1.	데이터요청
2.	화면처리
그리고 AJAX를 사용하지 않고 동적인 페이지요청이 들어왔을 때 페이지 자체를 HTML자체를 넘겨주게 되면 중복되는 데이터까지도 전달되어 효율이 떨어집니다. 

비동기적인 방식은 1번을 수행하면서 2번을 수행하는 방식을 말합니다. 그렇기 때문에 데이터 요청을 하게 되어도 화면이 계속 유지가 되며, 사용자가 웹사이트를 화면유지된 상태에서 사용할 수 있으므로 좀 더 상호작용적이다 라고 말할수 있습니다. 
원리
이 AJAX는 XMLHttpRequest라는 객체를 통해서 수행됩니다. 웹브라우저와 서버간의 다리를 이 XMLHttpRequest객체가 만들어주고 그 다리를 통해서 저희는 비동기적으로 데이터를 보내고 받을 수 있게 되는 것입니다.  
```
        const httpRequest = new XMLHttpRequest();  
        httpRequest.onreadystatechange = function(){
             if(this.readyState == 4 && this.status == 200){
                document.getElementById("app").innerHTML = this.responseText;
            } 
        } 
        httpRequest.open("GET", "/getAjax", true);
        httpRequest.send(); 
readyState정리
0: XMLHttpRequest 객체생성완료 open()함수는 아직 발동 x
1: loading: open()함수 발동
2: loaded: send() 함수 발동
3: loading: 다운로드 중, responseText가 작은 데이터의 부분을 가지고 있음. 
4. Done: 모든 작업이 끝남.
```
HTTP라이브러리 중 좋은 것은 fetch와 axios입니다. Promise가 리턴됩니다.
공통적으로 미지원 브라우저에 따라 pollyfill을 사용해야 하는 것은 동일합니다.
fetch api
```
fetch('http://example.com/movies.json')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson) {
    console.log(JSON.stringify(myJson));
});
```
axios 
axios는 현재 가장 성공적인 HTTP 클라이언트 라이브러리 중 하나 / request, response, etc에 대한 애러 나눠서 처리 가능해서 애러핸들링쉬움 / validateStatus 를 사용해 status에 관한 핸들링 /  
CancelToken을 이용한 요청취소 / 처음 vue에서는 vue-resource와 axios 중 고민했지만 vue 공식사이트에서도 axios를 추천 / 
그러나 Axios는 내부적으로 XMLHttpRequest를 사용하고 있는데 Service Worker등의 웹 최신 기술이 XMLHttpRequest를 지원하지 않으므로, Service Worker를 사용할 예정에 있는 프로젝트에서는 Axios를 사용할 수 없음

### 자바스크립트 이벤트 루프 등 비동기 함수 과정

### 생성자메서드에 화살표구문을 사용하면 어떤 이점

### SPA
 - NUXT
### Promise와 callback
 - CPS

### 불변객체
 - Object.freeze() / const 차이
 - Immutable

### 호이스팅

### 클로저

### 스코프체인

### 렉시컬 환경

### 이벤트 캡처링 & 버블링

### `call`과 `apply`, `bind`

### 이슈: 크로스도메인 (CORS)
 - JSONP
### 이슈: 여러언어 페이지

### 이슈: 기능이 제한된 브라우저

### `null`, `undefined`, `선언되지 않은 변수` 의 차이점

### 자바스크립트 원시 / 참조타입 & Number

### 호스트 객체와 내장 객체의 차이점

### 정적 클래스 멤버

### 실행 컨텍스트(Execution Context)

### 자바스크립트 최적화기법
 - script defer, async ㅇ
### Clean Code 최적화기법

### 가상요소선택자, 가상클래스 선택자(CSS Pseudo code)

### HTML5 & CSS최적화 
 - lazy 로딩 : 이미지, 스크립트, CSS 파일들이 lazy 로드 되어서 현 페이지의 응답시간을 향상시킴

### `cookie`, `sessionStorage`, `localStorage` 사이의 차이점

### 이미지태그 `srcset` 
 - 레티나 그래픽

### CSS 선택자 특이성

### 컨테이닝박스(block)

### "Resetting"과 "Normalizing" CSS 의 차이점

### `float`의 작동법

### `z-index`의 작동법

### `inline` 과 `inline-block` 그리고  `block` 

### `relative`, `fixed`, `absolute` 와 `static` 요소의 차이점

### @media 속성

### box-size : border-box

### 콘텐츠 숨기는 방법 

### "attribute"와 "property"의 차이점

### CSS 전처리기 SASS

### document `load` 이벤트와 document `DOMContentLoaded` 이벤트의 차이점

### `==`와 `===`의 차이점

### DOCTYPE

### http2

### 브라우저의 렌더링 과정
https://d2.naver.com/helloworld/59361 

### DIP(Dependency Inversion Principle) : 의존 역전 원칙 

<center>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F235E853E569870EA358109" width="700px">
</center>  

그림과 같이 자동차가 구체적인 타이어들(스노우타이어, 일반타이어, 광폭타이어)이 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 스노우타이어에서 일반타이어로, 또는 다른 구체적인 타이어로 변경돼도 자동차는 이제 그 영향을 받지 않는 형태로 구성된다. 
자동차는 자신보다 변하기 쉬운 스노우타이어에 의존하던 관계를 중간에 추상화된 타이어 인터페이스를 추가해 두고 의존 관계를 역전시키고 있다. 
이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.
상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다. 

### 브라우저렌더링 과정

### GPU 가속화 

### 리페인트 리플로우 감소

### SEO  

### OOP 개념 / ES5 & ES6 Class 차이

### AMP

### PWA

### SVG

### AMD와 CommonJS 차이

### Vanila JS

### JavaScript 코드디버깅

### ES6 스펙
 - 템플릿문자열의 좋은 예

### 함수형 프로그래밍 

### docker 

### Redis

### MongoDB

### Node.js

### D3.js

### JWT
### 쿠키와 토큰의 차이
[위로가기](#restful-api)
