 ## 싱글턴 패턴
  - 클래스의 인스턴스가 오직하나.
  - 똑같은 값을 넣어도 인스턴스가 하나다! 
  - 어떤 객체와도 같지 않다! 리터럴, 클래스로 생성하는 객체들을 일컫는다.  

 ## 팩토리 패턴
 객체를 생성한다. 비슷한 객체를 생성하는 반복작업을 수행한다. 

 ## 프로토타입 패턴
 프로토타입 인스턴스를 사용, 새 객체를 만든다. 

 ## 반복자패턴
 객체들의 집합을 효과적으로 반복하면서 탐색한다. 이터레이터객체가 쓰인다.  

 ## const 와 object.freeze()의 차이
 const는 변수의 재할당을 막지만 원시적인 Number, String에 한해서 입니다. 왜냐하면 객체의 경우에는 주소값이 할당되고 이 주소값은 바뀌지 않지만 그 값은 바뀔 수 있기 때문입니다. 따라서 const로 선언을 하면 객체의 값은 수정됩니다.  
 하지만 object.freeze()는 객체의 값이 바뀌는 것을 아예막기 때문에 수정되지 않습니다. 

 ## 자료구조
 자료를 저장하는 어떤 도구, 삽입, 삭제, 탐색을 위해 상황에 맞는 효율적인 자료구조들이 개발 되어있습니다. 
  - 리스트
  ```
  배열, 연결리스트로 이루어집니다. 
  연결리스트, 
  삽입과 삭제, O(1) 그러나 랜덤액세스가 안됩니다. 
  탐색, K번째 값을 찾기 위해서는 O(K)가 걸립니다. 
  
  배열, 랜덤 엑세스가 가능합니다. 인덱스 값을 알고 있다면
  탐색의 경우 O(1), 
  삽입과 삭제, O(K)가 걸립니다. 
  합병정렬의 경우에는 연결리스트가 더 좋습니다. 배열을 하나 덜 쓰게 되죠. 합병정렬은 마지막에 배열이 하나 더 필요해서 결과배열을 만듭니다. 
  
  데이터 추가와 삭제를 많이 하는 것은 연결리스트, 접근을 많이 하는 것은 
  배열로 하는것이 좋습니다. 
  
  ```
  - 해시테이블, 배열을 사용 빠른 검색속도, 데이터와 관련된 숫자, 이를 인덱스로 collision이 발생, 개방주소법, 다른 해시 버킷에 넣는 방법, 그리고 분리 연결법, 연결리스트나 트리를 만들어서 해당 버킷에 리스트를 추가하는 방식으로 해결한다.  
 
 ## 호이스팅 
 변수범위는 변수가 존재하는 컨텍스트, 어디에서 변수에 접근할 수 있는지를 명시적으로 나타냅니다. 
 모든 변수 선언은 호이스팅 됩니다. 변수의 선언이 할당할 때가 아닌 최상위로 호이스팅된다는 것입니다. 
 자바스크립트에서 실행 컨텍스트가 작동하는 방식 때문에 일어나는 것
  - 변수를 선언하고 초기화 했을 때 선언 부분이 최상단으로 끌어올려지는 현상
  - 함수 표현식이 아닌 함수 선언식일 때 함수 자체가 통째로 끌어 올려지는 현상
 ```
 const a = function(){}   [x] // 함수 표현식, 함수리터럴을 할당하는 구조, 호이스팅 x
 function a(){} [o] //함수 선언식, 호이스팅 o
 ```
 코드를 실행하는 순간 > 전역 컨텍스트, ES5 이전은 함수스코프를 따릅니다.

 ## 스코프체인
 변수가 없다면 찾아가는 여행입니다.
 지역변수, 전역변수를 가리키는 것을 lexical scoping이라 합니다. 함수를 처음 선언하는 순간, 내부의 변수는 자기 스코프로부터 가장 가까운 곳에 있는 변수를 계속 참조하게 됩니다. 