 ## 싱글턴 패턴
  - 클래스의 인스턴스가 오직하나.
  - 똑같은 값을 넣어도 인스턴스가 하나다! 
  - 어떤 객체와도 같지 않다! 리터럴, 클래스로 생성하는 객체들을 일컫는다.  

 ## 팩토리 패턴
 객체를 생성한다. 비슷한 객체를 생성하는 반복작업을 수행한다. 

 ## 프로토타입 패턴
 프로토타입 인스턴스를 사용, 새 객체를 만든다. 

 ## 반복자패턴
 객체들의 집합을 효과적으로 반복하면서 탐색한다. 이터레이터객체가 쓰인다.  

 ## const 와 object.freeze()의 차이
 const는 변수의 재할당을 막지만 원시적인 Number, String에 한해서 입니다. 왜냐하면 객체의 경우에는 주소값이 할당되고 이 주소값은 바뀌지 않지만 그 값은 바뀔 수 있기 때문입니다. 따라서 const로 선언을 하면 객체의 값은 수정됩니다.  
 하지만 object.freeze()는 객체의 값이 바뀌는 것을 아예막기 때문에 수정되지 않습니다. 그러나 2단계이상 깊이의 객체면 속성이 변경이 가능합니다. 
 

 ## 자료구조
 자료를 저장하는 어떤 도구, 삽입, 삭제, 탐색을 위해 상황에 맞는 효율적인 자료구조들이 개발 되어있습니다.

  - 리스트 : 배열, 연결리스트
  ``` 
  1) 연결리스트
   삽입과 삭제, O(1) 그러나 랜덤액세스가 안됩니다. 
   탐색, K번째 값을 찾기 위해서는 O(K)가 걸립니다. 
  
  2) 배열, 랜덤 엑세스가 가능합니다. 인덱스 값을 알고 있다면
   탐색의 경우 O(1), 삽입과 삭제, O(K)가 걸립니다. 
   합병정렬의 경우에는 연결리스트가 더 좋습니다. 배열을 하나 덜 쓰게 되죠.
   합병정렬은 마지막에 배열이 하나 더 필요해서 결과배열을 만듭니다. 
  
  데이터 추가와 삭제를 많이 하는 것은 연결리스트, 탐색을 많이 하는 것은 
  배열로 하는것이 좋습니다. 
  
  ```
  - 해시테이블, 배열을 사용하여 빠른 검색속도를 보여준다. 데이터와 관련된 숫자를 인덱스로 만들어 필요한 값을 추출한다. 이 때 동일한 주소가 반환되어 가 발생되어 collision이 발생하기도하는데 아래의 3가지 방법으로 해결한다. 
  1) 개방 주소법 : 해시 테이블 내의 새로운 주소를 찾아 입력 
   - 주소를 +1, ^2를 찾거나 처음부터 2개의 해시함수준비, 해시테이블을 늘리는 방식이 있다. 
  2) 체이닝, 각 데이터를 해당 주소에 있는 연결리스트에 삽입하여 해결, 개방해싱  
 ## 호이스팅 
 모든 변수들이 var로 선언될 때 범위가 가장 상단으로 간다. 
 함수 선언도 마찬가지다. 
 함수, 변수 선언이 컴파일 단계에서 메모리에 추가되는 것이다. 
 ```
    a = 3;
    console.log(a);
    var a; 
    //3
    console.log(a);
    var a = 3;
    // undefined
 ```
 자바스크립트는 선언만 호이스팅이 되고 할당, 초기화는 호이스팅이 되지 않는다. 
 앱성능 사이트 : https://app.sessionstack.com/#/signup 

 ## 스코프체인
 변수가 없다면 좀 더 위쪽으로 찾아가는 여행입니다.
 함수를 처음 선언하는 순간, 내부의 변수는 자기 스코프로부터 가장 가까운 곳부터 변수를 계속 참조하게 됩니다. 
 `스코프 : 어떤 변수들에 접근할 수 있는 지를 정의, 함수 & 블록 스코프로 나누어집니다.`
 
 변수의 유효범위는 실행 중에 설정되지 않고, 정의될 때의 함수단위, "렉시컬한 환경"으로 설정이 되며    
 함수가 다른 함수 내부에서 정의되었을 때 내부함수는 외부함수의 변수에 접근 가능하지만
 외부함수는 내부함수의 변수에 접근 불가 
 이를 "렉시컬 스코핑"이라고 합니다.
 ```
 function outerFunction () {
  const outer = 'I’m the outer function!'
    
  function innerFunction() {
     const inner = 'I’m the inner function!'
     console.log(outer) // I’m the outer function!
  }
    
  console.log(inner) // Error, inner is not defined
}
```
여러 레이어의 함수는 여러 레이어로 이루어진 단방향 투과성유리를 생각하면 되듯이 안쪽에서 바깥쪽은 참조가 가능해도 바깥쪽에서 안쪽은 불가능
합니다.

```
function prepareCake (flavor) {
  return function () {
    setTimeout(_ => console.log('Made a ${flavor} cake!', 1000))
  }
}
const makeCakeLater = prepareCake(‘banana’)
// And later in your code…
makeCakeLater()
// Made a banana cake!
```  

이렇게 클로저를 이용하면 렉시컬 환경이 끝나면 GC가 회수해야 하지만 그렇지 않게 만들 수 있습니다. 
함수로 래핑하여 flavor이라는 인자를 참조하여 쓸 수 있습니다.

