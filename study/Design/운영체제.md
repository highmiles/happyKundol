# 컴퓨터의 구조
 ## 운영체제 의미
 - 운영체제는 컴퓨터 시스템의 자원을 효율적으로 관리해주는 것
* 자원 : 프로세스, 파일, 메시지, 기억장치, 입출력 장치 등 
1. 주어진 하드웨어를 가지고 실행중인 프로그램들에게 짧은 시간씩 CPU를 번갈아 할당함.
2. 메모리 공간을 적절히 어떻게 분배를 할 것인가 하는 고민에 대한 해결이 담긴 것. 
 - 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
   * 동시 사용자 / 프로그램 들이 각각 독자적 컴퓨터에서 수행되는 것 같은 "환상"을 제공
   * 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행해서 쉽게 하드웨어를 다룸

 ## 운영체제의 분류
1. 작업별로
 - 단일 작업, 한 번에 하나의 작업만 처리
 - 다중작업은 동시에 두 개 이상의 작업처리
 > 현재의 컴퓨터는 다중작업이 가능하다. 

2. 사용자별
 - 단일사용자, 다중사용자

3. 어떻게 처리하는가
 - 일괄처리, 작업요청의 일정량을 모아서 한꺼번에 처리하는 것
 - 시분할, 타임쉐어링 등의 단위로 분할
현재의 컴퓨터는 짧은 응답시간으로 interactive한 방식을 가지고 있다

4. 시스템
 - 실시간, 리얼타임 OS가 있다. 정해진 시간안에 어떠한 일이 반드시 종료됨을 보장합니다. 원자로, 공장 제어, 미사일 제어, 반도체 장비 등에 사용됨
 1) 경성 실시간 시스템
 2) 연성 실시간 시스템

 ## 운영체제의 하는 일 
1. CPU 스케줄링
 - CPU를 누구에게 주는 가를 결정하는 것
 - CPU의 소유권에 따라 인스트럽션을 실행가능
2. 메모리관리
 - 한정된 메모리를 어떤 프로그램에 얼만큼 할당해야 하는가를 관리 하는 것입니다. 
 - 어떤 프로그램의 과거에 사용된 양을 기준으로 파악해서 메모리관리를 함.
3. 디스크 파일 관리, 디스크에 파일을 어떻게 보관하는지에 대한 것입니다. 
4. I/O디바이스 관리, 입출력장치와 컴퓨터 간에 어떻게 정보를 주고 받게 할까에 대한 것입니다. 

이외에도 프로세스관리, 프로세스의 생성과 삭제, 자원 할당 및 반환 등을 운영체제가 관리한다. 
이 때 *운영체제는 인터럽트*에 의해 움직입니다.  

 ## 가상메모리 
 가상메모리 사용, 여러 프로세스는 CPU와 메인 메모리를 공유한다. 프로세스들이 존재하는 
 메모리 여유가 없이 지나치게 많은 요구를 할 경우 이를 방지하기 위해 가상메모리가 존재한다.
 OS측면에서 자동작동한다는 점에서 좋다. 
  - 당장 사용하지 않는 영역을 하드디스크로 옮긴 뒤, 필요할 때만 램에 데이터를 불러와 올리고 
    사용하지 않으면 하드디스크로 내림으로써 램을 효과적으로 관리한다. 
  - 메모리관리의 단순화, 각 프로세스마다 가상메모리의 동일한 주소 공간을 배정할 수 있으므로 메모리 관리가 단순해진다. 
  - 메모리 용량 및 안정성 보장, 무한한 가상메모리 공간을 배정
  - 물리적인 RAM의 허용치를 넘어설 경우 하드디스크 등 보조기억장치를 쓰는데 이는 RAM보다 매우 느리기 때문에 RAM을 초과하는 데이터를 다뤄서 보조기억장치를 끌어다 쓸 경우 
  시스템의 속도가 확연히 느려진다. 

 ## 컴퓨터 시스템 구조, CPU, Memory, DMA, Timer, Device Controller, Disk
CPU
 - 메모리, 로컬 버퍼 접근 가능
 - 본인의 메모리주소에 맞는 인스터럭션만 실행! 
 - 프로그램자체적으로 인터럽트 라인을 설게해서 순차적인 인터럽트 실행을 바꿔서 OS에 제어권을 
 줄 수 있다. 그렇게 해서 OS의 시스템 콜을 통해 어떤 장비에게 요청을 할 수 있다. 

 ## 인스트럭션
CPU에서 메모리를 통해 기계어를 읽는 것
CPU는 직접적으로 IO디바이스에게 접근하지 않고 *메모리*에게만 접근해서 인스트럭션을 실행한다. 그러나 “디바이스의 디스크”에게 할 일이 생긴다면 메모리가 아닌 IO 디바이스의 컨트롤러, 장치를 제어하는 작은 CPU에 요청을 하게 된다.

 ## 차이? 

 ## 인터럽트
 현대의 운영체제는 인터럽트에 의해 구성된다.
 인터럽트는 CPU에게 무언가를 알려주는 일을 한다. 
 하드웨어 인터럽트, Trap(소프트웨어 인터럽트)가 있다. 
 Trap 은 프로그램 오류가 나거나 System call로 프로그램이 커널 함수를 호출하는 경우에 발동된다. 
 과정 : IO에 요청 >> 소프트웨어 인터럽트 >> IO작업이 끝나면 >> 하드웨어 인터럽트로 끝났음을 알려준다. 

 ## 시스템콜
 사용자 프로그램이 운영체제의 서비스를 받기 위해서 커널 함수를 호출하는 것
 ex) 사용자프로그램이 IO요청 >> 무조건 OS통해서 요청을 수행 >> 커널함수를 통해 수행
 이렇게 사용자 프로그램이 호출하는 것을 trap이라 부른다. 

 이 trap을 이용 인터럽트 벡터로 이동하여 제어권이 인터럽트 벡터가 가리키는 "인터럽트 서비스 루틴"으로 이동하고 올바른 I/O요청인지 확인 후 I/O 를 수행합니다.  
 I/O 완료 시 제어권을 수행한 trap 다음 명령으로 옮긴다. 
 > 인터럽트 벡터 : 인터럽트 주소의 특정위치 
 > 운영체제에 특정 행위를 요청(시스템 콜) : 사용자 프로그램이 소프트웨어적으로 인터럽트 라인을 설계해서 인터럽트를 거는 것(CPU와 메모리가 아닌 좀 더 멀리 있는 경로를 설계하는 것)

 ## timer
CPU는 보통의 경우 프로그램들에 각각 할당량을 주면서 효율적으로 작동하는데 “무한루프등 소모량이 많은 프로그램”이 작동할 때를 방지하기 위해 타이머가 존재 
"몇세컨드안에 실행되어야 한다" 라는 것을 정하고 특정 프로그램에 시간제한을 다는 역할

 ## Device Controller
컴퓨터와 연결되어있는 IO디바이스들은 작은 CPU가 붙어있음 이를 컨트롤러
이 디바이스들의 작업공간, 메모리를 로컬 버퍼라고 부릅니다. 

## 레지스트리
CPU안에서 메모리보다 좀 더 빠른 데이터를 저장할 수 있는 공간

## modebit
 지금 실행하는 프로그램이 사용자 프로그램인지 운영체제인 지를 파악해주는 역할
 IO디바이스는 운영체제를 통해서만 작동하게끔해야 한다.
 왜냐하면 사용자프로그램을 통해서만 운용된다면 카메라가 갑자기 켜지는 등 나쁜 짓을 할 수 있기 때문에 운영체제를 통해서만 작동할 수 있어야 하고 이를 위해 modebit이 존재한다. 
 modebit의 0, 모니터모드 1, 사용자모드를 통해 이를 관리
 1, 사용자모드일 경우에는 IO 디바이스에 시스템콜을 못하게 막습니다. 즉 *한정된 인스트럭션*만 가능하게끔 합니다.
​  

## DMA 컨트롤러, Direct Memory Access
메모리는 CPU만이 접근이 가능하고 하는 일도 많습니다. 
CPU는 메인 메모리 및 IO의 로컬버퍼에게 접근 가능하다 보니까 CPU에게만 너무 많은 인터럽트요청이 들어온다. 그래서 DMA 컨트롤러를 두고 있습니다. 
 > 이 때, CPU와 DMA컨트롤러의 메모리 중첩 사용을 방지하기 위해 메모리 컨트롤러가 존재한다. ​

## CPU스케쥴링
CPU이용률을 극대화하기 위해, 즉 시스템의 자원을 효율적으로 사용하기 위해서 어느 프로세스가 CPU를 차지 할 것인가에 대한 순서 또는 방법을 결정짓는 작업을 말한다. 어느 시점에서 실행되고 있는 프로세스는 단 한개이며 여러개의 프로세스를 번갈아 가며 실행하는 것이다. 
```
생성 : 프로세스는 준비단계에 머무른다. CPU를 점유하길 희망하는 상태준비 상태에서 실행 상태로 넘어가려면 작업 스케줄러가 선택해 주어야만 한다. 

디스패치 : 준비 상태에서 실행 상태로 전이되는 과정을 말하며, 이는 작업 스케줄러가 해당 프로세스를 선택하여 실행되어지는 것으로, 이때 실행된 프로세스가 CPU를 점유하게 된다.

인터럽트 : 인터럽트 신호를 받게되면, 실행중이던 프로세스는 준비 상태로 전이되고, 우선순위(Priority)가 높은 프로세스를 "실행 상태"로 전이시킨다. 
```
> 프로세스는 각각 우선순위를 부여받고, 우선순위에 따라 프로세스가 준비 상태로 전이되거나, 실행 상태로 전이된다. 

입출력 또는 이벤트 대기, CPU를 점유하고 있는 프로세스가 입출력 처리를 해야만 하는 상황이라면, 실행되고 있는 프로세스는 실행 상태에서 대기/보류 상태로 바뀝니다. 그리고 대기 상태로 바뀐 프로세스는 입출력 처리가 모두 끝날때까지 대기 상태로 머문다. 그리고 실행 상태이던 프로세스가 대기 상태로 전이됨과 함께, 준비 상태이던 또다른 프로세스가 실행 상태로 전이됩니다. 또한 대기 상태인 프로세스는 우선순위가 부여되지 않으며 스케줄러에 의해 선택될 수 없다. 

입출력 또는 이벤트 완료, 입출력 처리가 끝난 프로세스는 대기 상태에서 준비 상태로 전이되어 스케줄러에게 선택될 수 있게 된다. 추가로 프로세스를 종료(Terminate)시킬 때에도 Blocked 상태를 거칠 수 있다.

## 커널 주소 공간의 내용
운영 체제 커널의 구조는 다음과 같다. 
code : 시스템 콜, 인터럽트 처리 코드 등.. 
data : 프로세스, CPU, MEM, DISK
stack : 커널 스택 

## 프로그램 실행
user mode >> kernel mode >> user mode >> kernel mode
시스템콜을 하면 user mode에서 kernelmode로 전환되며 이 후에 다시 user mode로 전환되며 이는 
프로그램이 끝날 때까지 반복된다.  

## 메모리 계층 구조 
레지스트리, CPU와 같은 속력으로 동작, CPU가 일을 할 때 임시로 자료를 저장함.
캐시메모리, CPU와 RAM사이를 이어주는 역할
메인메모리, RAM
----- 이 3가지를 주 기억장치, 휘발성메모리라 한다. 
SSD, HDD, 보조 기억장치 

# 프로세스

##프로세스의 문맥
프로세스의 모든 상태를 나타내는 것을 프로세스의 문맥이라 한다. 
1. 하드웨어 문맥
2. 주소 공간, code, data, stack
3. 프로세스 커널관련 자료구조, PCB
 - 프로세스 하나당 커널스택 하나가 생성 

## 프로세스 상태
 - Running, CPU를 잡고 인스트럭션을 수행중인 상태 [active]
 - Ready, CPU를 기다리는 상태[active]
 - Blocked, 오래거리는 작업 중이라 CPU로 실행 못하는 상태[active]
 - Suspended, 메모리를 통째로 빼앗긴 상태[inactive]

## PCB
 - 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보 
 - 다음의 구성요소
  1) Process ID
  2) CPU 수행 관련 하드웨어 값
  3) 메모리 관련 Code, data, Stack의 위치 정보
  4) 파일 관련

## 문맥교환
CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
 - CPU는 CPU를 내어주는 프로세스의 상태를 그 프로세스 PCB에 저장을 하고 새롭게 얻는 프로세스 상태를 PCB에서 읽어온다.

## 프로세스를 스케줄링하기 위한 큐
PCB를 줄세운다.
JOb queue, 현재 시스템 내 모든 프로세스의 집합
Ready Queue, CPU를 잡아서 실행되기를 기다리는 프로세스 집합
Device Qeue, I/O 처리를 기다리는 프로세스 집합

## 스케줄러
장기스케줄러, 시작 프로세스 중 어떤 것을 Ready queue로 보낼 것인가. 
단기스케줄러, 어떤 프로세스를 다음번에 running할 것인가. 
중기스케줄러, 프로세스에게서 memory를 뺏는 문제(지금의 시스템은 중기스케줄러로 되어있다.)
 - 일단 올려놓고 안된다면 쫓아낸다.

## 동기식 입출력과 비동기식 입출력
입출력을 실행하지 않고 기다리면 동기식이고
입출력을 해놓고 나서 인스트럭션은 비동기식

## 쓰레드
프로세스가 만들어지면 code, data, stack이 만들어지고 이를 관리하기 위해 PCB를 둔다.
이 PCB에 쓰레드가 여러개 들어가 있는데 이 쓰레드에는 Program Counter, Registers가 있습니다.
 >  Program Counter : 코드 어느부분을 가리키면서 실행하는 것에 대한 정보
동일한 일을 하는 프로세스가 여러개 있다하면 이를 프로세스 하나씩 만들게 되면 별도의 메모리 주소공간이
낭비가 됩니다. 이를 위해 쓰레드가 나타납니다.  
프로세스 하나당 공유할 수 있는 것은 최대한 공유
 - 메모리 주소공간 공유
 - 프로세스 상태 공유 
 - 쓰레드끼리도 공유, 동료 쓰레드와 공유하는 부분을 task
쓰레드의 구성은 program counter, register set, stack space로 되어 있다. (CPU에 관한 정보들)
쓰레드는 lightweight process라 부르고 하나의 쓰레드만 가지고 있는 것을 heavyweight process라 한다.

장점 
 - 하나가 blocked하는 상태여도 다른 쓰레드는 running상태여서 빠른 처리를 할 수 있다. 
 - 동일한 일을 하는 도중 협력해서 처리를 하면 성능 향상을 얻을 수 있다. 
 - CPU가 여러개 달린 컴퓨터에는 병렬성을 높일 수 있다. (계산시 하나당 맡아가지고 가능)

