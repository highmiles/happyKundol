1일차
=====
# 컴퓨터의 구조
## 운영체제 의미
 - 운영 체제는 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스
 - 컴퓨터 자원을 효율적으로 관리하기 위한 시스템, 한정된 메모리 공간을 효율적으로 분배하는 참된 일꾼
 - 운영체제는 하드웨어와 소프트웨어를 관리하는 소프트웨어 전체
 이러한 운영체제는 어느 기기에서 어떠한 형태로도 나타날 수 있습니다. 비단 PC용 윈도우즈만이 운영체제가 아니고, MP3 플레이어를 켜면 전원이 들어와 장치를 깨우고 사용자의 명령에 따라 음악을 재생하는 동작들을 관리하는 것들도 전부 운영 체제라 할 수 있습니다. 단, 이런식으로 전자기기에 공장 출고시 설치되며 애플리케이션 설치를 통한 기능 추가를 할 수 없는 것은 보통 펌웨어(firmware)라고 부릅니다. 

## 운영체제의 역할
1. CPU 스케줄링
CPU를 어떤 프로세스에게 주는 것을 결정하는 것, CPU 소유권에 따라 해당 프로세스의 인스트럭션이 가능합니다.  
2. 메모리관리
한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는가를 관리 하는 것입니다. 
3. 디스크 파일 관리
디스크 파일을 어떻게 보관하는지에 대한 것입니다. 
4. I/O디바이스 관리
입출력장치와 컴퓨터 간에 어떻게 정보를 주고 받게 할까에 대한 것입니다. 

이외에도 프로세스관리, 프로세스의 생성과 삭제, 자원 할당 및 반환 등을 운영체제가 관리합니다. 
이 때 운영체제는 **인터럽트**에 의해 움직입니다.  
 - 인터럽트 : 마이크로 프로세서가 device관련 / 예외발생 처리요청이 들어오면 처리를 할 수 있게 해주는 것

## 컴퓨터 시스템 구조, CPU, DMA, Timer, Modebit, Device Controller
### CPU
메모리, I/O 디바이스의 작게 설정되어있는 메모리인 로컬 버퍼에 접근하여 일을 합니다. 
 - 일이란 본인의 메모리주소에 맞는 딱 자기 할일만 하는 **인스터럭션**만 실행하는 것을 말합니다. 

프로세스(프로그램)가 요청할 때 메모리만 읽어들이면서 실행을 하는데 저 멀리 있는 I/O 디바이스에 요청을 할 때는 좀 다릅니다. 
이때는 새로이 인터럽트 라인을 설게 후 순차적인 인터럽트 실행을 중지하고 OS에 제어권을 주어서 OS에 **시스템 콜**을 요청해 원하는 디바이스로 향해 작은 로컬버퍼에 접근,원하는 요청을 합니다. 
 > 인스트럭션 : CPU에서 메모리를 통해 기계어를 읽는 것  

> 시스템콜
운영체제 커널이 커널에 접근하기 위한 인터페이스이자 
사용자 프로그램이 운영체제의 서비스를 받기 위해서 커널 함수를 호출하는 것을 말합니다. 
 - 사용자프로그램이 I/O요청(**Trap**)이 들어오면 무조건 OS통해서 요청을 수행하게 되는데 이 때 커널함수를 통해 수행
 - **Trap**이 발동하게 되면 인터럽트 벡터로 이동하여 제어권이 **인터럽트 벡터**가 가리키는 **인터럽트 서비스 루틴**으로 이동하고 올바른 I/O요청인지 확인 후 I/O 를 수행합니다. 그 이후 CPU의 제어권을 다음 명령으로 옮깁니다. 
  - 수행하는 과정에서 사용자모드와 커널모드(모니터모드)가 번갈아가면서 작동되는데 예를 들어 fs.readFile 이라는 함수가 작동되면 사용자모드에서 함수가 작동되고 파일을 읽을 때는 커널모드로 들어가서 읽고 다시 사용자모드로 돌아가서 그 밑의 로직을 수행하게 되는 것입니다. 
```
fs.readFile >> 
        유저모드 >>  >> 
=============시스템콜================
        커널모드   >> 
```
- 인터럽트 벡터 : 인터럽트 주소의 특정위치   
- 커널 : 운영체제의 핵심부분이자 보안, 자원관리, 추상화를 담당합니다.  

### DMA 컨트롤러, Direct Memory Access
메모리는 CPU만이 접근이 가능하고 하는 일도 많습니다. 
CPU는 메인 메모리 및 IO의 로컬버퍼에게 접근 가능하다 보니까 CPU에게만 너무 많은 인터럽트요청이 들어오기 때문에 도와주는 일꾼인 DMA 컨트롤러를 두고 있습니다. 
이 때, CPU와 DMA컨트롤러의 메모리 중첩 사용을 방지하기 위해 메모리 컨트롤러가 존재합니다. 

### Timer
CPU는 보통의 경우 프로그램들에 각각 할당량을 주면서 효율적으로 작동하는데 “무한루프등 소모량이 많은 프로그램”이 작동할 때를 방지하기 위해 타이머가 존재합니다. "몇세컨드안에 실행되어야 한다" 라는 것을 정하고 특정 프로그램에 시간제한을 다는 역할을 합니다. 

 ### modebit
 지금 실행하는 프로그램이 사용자 프로그램인지 운영체제인 지를 파악해주는 역할
 IO디바이스는 운영체제를 통해서만 작동하게끔해야 한다.
 왜냐하면 사용자프로그램을 통해서만 운용된다면 카메라가 갑자기 켜지는 등 나쁜 짓을 할 수 있기 때문에 운영체제를 통해서만 작동할 수 있어야 하고 이를 위해 modebit이 존재합니다. 
 modebit의 0, 모니터모드 1, 사용자모드를 통해 이를 관리
사용자모드일 경우에는 IO 디바이스에 시스템콜을 못하게 막습니다. 즉 **한정된 인스트럭션**만 가능하게끔 합니다.

 ### Device Controller
컴퓨터와 연결되어있는 IO디바이스들은 작은 CPU가 붙어있음 이를 컨트롤러
이 디바이스들의 작업공간, 메모리를 로컬 버퍼라고 부릅니다.   

## 인터럽트
 현대의 운영체제는 **인터럽트**에 의해 구성됩니다. 
 인터럽트는 CPU에게 무언가를 알려주는 일을 하며 그렇게 해야할일들을 처리하며 OS가 동작합니다. 
 1. 하드웨어 인터럽트
 2. 소프트웨어 인터럽트, Trap
 - Trap 은 프로그램 오류가 나거나 System call로 프로그램이 커널 함수를 호출, **시스템콜**을 하는 경우에 발동된다. 
 - 과정 : IO에 요청 >> 소프트웨어 인터럽트 >> IO작업이 끝나면 >> 하드웨어 인터럽트로 끝났음을 알려준다.   

## 메모리 구조 
| 이름 | 설명 |
|:--------|:--------|
| code | 시스템 콜, 인터럽트 처리 코드 등의 사용자코드 |
| data | 전역변수, 프로그램이 종료시에 사라짐 |
| heap & stack | 동적변수 & 지역변수, 함수가 할당 | 
| 커널영역 | 시스템 운영에 필요한 메모리 |  
## 메모리 계층 구조 
| 이름 | 역할 | 특징 |  
|:--------|:--------|:--------|
| 캐시메모리 | CPU와 RAM사이를 이어주는 역할 | 휘발성 |  
| 메인메모리 | 커널 RAM | 휘발성 |  
| SSD, HDD | 보조기억장치 | 비휘발성 |    

 - CPU와 하드디스크, 그리고 램 사이의 상관 관계
일반적인 컴퓨터 작업의 과정을 살펴보면, 램은 하드디스크로부터 일정량의 데이터를 복사해 임시 저장한 후, 이를 필요 시마다 CPU에 빠르게 전달하는 역할을 한다. 이후부터는 속도가 느린 하드디스크는 배제하고 빠른 CPU와 램끼리만 데이터를 교환하므로 전반적인 작업을 고속으로 처리할 수 있다. 이러한 이유로, 하드디스크가 단순히 데이터를 보관하는 역할에 그치는데 비해, 램은 컴퓨터 전반의 성능에 미치는 바가 크다고 할 수 있다. 이에 따라 램은 주기억장치, 하드디스크는 보조기억장치로 분류된다.

일반적으로 컴퓨터 게임을 실행할 때 램과 하드디스크의 상관 관계를 확인할 수 있다. 게임을 처음 실행할 때, 또는 각 스테이지를 넘어가는 도중에 화면이 정지하며 ‘로딩 중(Now Loading)’, 혹은 ‘기다려 주세요(please wait)’ 등의 메시지가 나오는 것을 본 적이 있을 것이다. 여기서 말하는 ‘로딩(적재)’이라는 것이 하드디스크에서 데이터를 읽어 램으로 전송하는 과정을 의미한다. 로딩이 끝나야 비로소 게임을 플레이 할 수 있다. 

# 프로세스
## 프로세스의 문맥
프로세스의 모든 상태를 나타내는 것을 프로세스의 문맥이라 한다. 
1. 하드웨어 문맥
2. 주소 공간, code, data, stack
3. 프로세스 커널관련 자료구조, PCB(주소공간위치정보, Process Control Block)
 - 프로세스 하나당 커널스택 하나가 생성 

## 프로세스 상태
 - Running, CPU를 잡고 인스트럭션을 수행중인 상태 [active]
 - Ready, CPU를 기다리는 상태[active]
 - Blocked, 오래거리는 작업 중이라 CPU로 실행 못하는 상태[active]
 - Suspended, 메모리를 통째로 빼앗긴 상태[inactive]

## PCB, Process Control Block
 - 운영체제가 각 프로세스를 관리하기 위해 프로세스당 유지하는 정보 
 - 다음의 구성요소
  1) Process ID
  2) CPU 수행 관련 하드웨어 값
  3) 메모리 관련 Code, data, Stack의 위치 정보
  4) 파일 관련 
 - CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정에서 CPU는 CPU를 내어주는 프로세스의 상태를 그 프로세스 PCB에 저장을 하고 새롭게 얻는 프로세스 상태를 PCB에서 읽어옵니다. 

## 쓰레드
프로세스가 만들어지면 [code, data, stack, heap]이 만들어지고 이를 관리하기 위해 PCB를 둡니다. 
이 PCB에는 쓰레드가 여러개 들어가 있습니다.  
[code, data, stack, heap]를 **각각** 생성하는 프로세스와는 달리 쓰레드는 stack을 제외한 정보를 **모두 공유**합니다. 
좀 더 자세히 말하면 쓰레드는 Program Counter, registers(CPU레지스터값), stack space는 별도로 유지하지만 data, code, heap을 공유합니다.  
 - Program Counter : 코드 어느부분을 가리키면서 실행하는 것에 대한 정보

동일한 일을 하는 프로세스는 독립적으로 있기 때문에 별도의 메모리 주소공간이 낭비되지만 쓰레드는 그렇지 않죠. 
프로세스 하나당 공유할 수 있는 것은 최대한 공유합니다. 
 - 메모리 주소공간 공유
 - 프로세스 상태 공유 
 - 쓰레드끼리도 공유, 이 때 동료 쓰레드와 공유하는 부분을 task라고 합니다.  

쓰레드는 lightweight process라 부르고 하나의 쓰레드만 가지고 있는 것을 heavyweight process라 합니다. 
쓰레드의 장점 
 - 하나가 blocked하는 상태여도 다른 쓰레드는 running상태여서 빠른 처리를 할 수 있다. ex) WebSite Request시
 - 동일한 일을 하는 도중 협력해서 처리를 하면 성능 향상을 얻을 수 있다. 
 - CPU가 여러개 달린 컴퓨터에는 병렬성을 높일 수 있다. (계산시 하나당 맡아가지고 가능)

 ## 프로세스 생성, fork, exec
 보통은 자식과 부모프로세스 생성시 자원을 공유하지 않습니다. 
  - fork : 자식이 부모의 주소공간을 그대로 복사하여 (binary & OS data) 새로운 프로세스 생성(복제생성)
  - exec : 새로운 프로그램을 그 공간에 올릴 수 있다. 
 두개의 프로세스 생성 과정은 독립적이며 이 모든게 시스템 콜을 통해 생성된다! 부모가 OS에 요청을 해서 생성 됩니다.   

 ## 프로세스 종료, exit, abort
exit
프로세스의 마지막 명령 수행 후, OS에 알려준다. (자식이 부모에게 죽었다 알리며 자원을 모두 반납하고 죽는다.)
 - 자식이 먼저 죽고 부모가 그 다음에 죽는다. 
 - 프로그램에 안적어도 메인함수 리턴되는 위치에 컴파일러가 넣어준다. 

abort
부모프로세스가 자식의 프로세스를 강제로 종료시킴
 - 자식이 할당된 자원의 한계치를 넘어섬
 - 자식에게 할당된 태스크가 더이상 필요하지 않음 
 - 부모가 종료할 경우 제거 된다. 
 - 키보드로 kill, break를 친경우 

 ## 프로레스 대기, wait
 자식프로세스의 일이 끝날 때까지 부모프로세스가 기다리는 과정

 ## 프로세스 간 협력
 IPC, Inter Process Comunication
 1. 메시지패싱, 커널을 이용해 메시지 전달
  - 메일박스 또는 포트를 통한 간접방식
  - 전달프로세스이름표기 직접방식
 2. 메모리 공유
  - 쓰레드끼리는 메모리가 공유되기 때문에 완전한 협력이 가능 

2일차
=====
 # CPU Scheduling  
 프로그램이 실행될 때 IO burst, CPU burst가 반복되서 일어나는데 이 때 누구에게 CPU를 줄 것인가를 결정하는 과정입니다. 어느 시점에서 실행되고 있는 프로세스는 단 한개이며 CPU는 여러개의 프로세스를 아주 빠른 속도로 번갈아 가며 실행하는데 누구에게 먼저 이 일꾼녀석을 줘야 할지를 결정하는 것이죠. 
  - IO burst, IO에서 인스트럭션을 하는 과정
  - CPU burst, CPU에서 인스트럭션을 하는 과정 
   
## 문맥교환, context switch
하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업입니다. 인터럽트가 발생이 되면 CPU 스케쥴링에 따라 현재 작동되고 있는 프로세스의 정보를 커널이 PCB에 저장을 하고 요청된 프로세스의 문맥을 불러와 실행시킵니다.  
이 때 **dispatcher**가 스케쥴링에 의해 결정된 프로세스로 CPU제어권을 넘겨주는 역할을 합니다.   
 - 인터럽트[preemptive, 선점형방식]
timer / I/O완료후의 발생되는 인터럽트[preemptive, 선점형방식]
그 외 [nonpreemptive, 비선점형방식] 
 - 문맥
CPU에서 일하고 있는, 실행중인 프로세스의 레지스터 세트를 말합니다. 

 ## CPU 스케쥴링 알고리즘
매 CPU burst시 어떤 알고리즘을 써야 하는가. 
 - CPU 이용률이 높아야 좋은 것이다. 
 - 처리량, 주어진 시간에 많은 일을 해야 한다. 
 - 소요시간, CPU를 쓰러 들어와서 IO를 하러 나갈 때까지의 시간이 짧아야 한다. 
 - 대기시간, ready queue에 있던 시간이 짧아야 합니다. 
 - 응답시간, 일을 시작해서 결과가 나오는 시간, 짧아야 합니다. 
 ### FCFS[비선점형]
가장 먼저 온게 가장 먼저 처리, 길게 수행되는 프로세스 때문에 Convoy Effect, Queue에서 오래 기다리는 현상발생 
 ### SJF, Shortest Job First[비선점형]
 - 가장 짧은 프로세스를 가장 먼저 스케쥴링 합니다. 
 - 긴 시간을 가진 프로세스가 실행이 안되는 현상, StarVation이 발생합니다. 
 - 평균 대기시간이 가장 짧습니다. 
 - 하지만만 실제로는 CPU시간을 알 수 없기 때문에 과거의 CPU burst time의 흔적을 이용해 추측해내서 사용합니다.
 - Priority Scheduling의 일종입니다.  
 ### Priority Scheduling[비선점형]
SJF의 StarVation을 에이징, Aging을 통해 극복한 것. 오래될수록 우선순위를 높여서 막을 수 있습니다.

 ### RB / Round Robin 현대적 컴퓨터가 쓰는 스케쥴링[선점형]
 - Priority Scheduling의 일종
 각 프로세스는 동일한 할당시간을 주고 그 시간안에 안끝나면 다시 ready queue 뒤로 갑니다. 
 예를 들어 q만큼의 할당시간을 주었을 때 (n - 1)q시간이 지나면 자기 차례가 오게 됩니다. 
 할당시간이 너무 크면 FCFS가 되고 짧으면 context switch의 잦음으로 인해 오버헤드,즉 비용이 커집니다. 
 일반적으로 turn around, 전체작업 시간은 길어지지만 평균 응답시간은 짧아진다는 특징이 있다. 

 ## CPU 스케쥴링 알고리즘 평가방법
 큐잉모델 : 확률분포로 큐에 도착하는 비율과 서비스가 끝난후의 비율을 비교해서 각종 퍼포먼스의 인덱스를 계산
 구현 & 성능측정모델 : 실제 시스템에 적용시킨 알고리즘 구현, 실제작업성능 비교
 모의실험모델 : 알고리즘 모의프로그램으로 구현

 # 프로세스 동기화
 race condition 발생시 동기화가 깨지며 race condition은  
 1. 커널 도중 인터럽트가 발생시 일어납니다. 
 2. 프로세스가 시스템콜을 하여 커널모드로 실행중인데 context switch가 일어나는 경우(할당시간이 끝나서 연산 도중에 다른 프로세스가 실행)
 에 일어납니다. 
 - 이들은 순서대로 끝날 때까지 기다렸다가 실행하면 해결할 수 있습니다. (실행순서를 정한다.) 
 3. 멀티 CPU에서 공유자원에 다중작업이 발생할 때도 일어납니다. 
 - 이들은 작업시 데이터에 lock을 걸면 된다.  
 - semaphore은 공용자원이다. 멀티태스킹 OS, critical section문제를 해결하는 데 쓰이고 프로그래머가 이 공용자원의 상태를 정의할 수 있습니다.  
 - critical section은 공유자원에 동시에 접근이 일어날 때 예상치 않은 행동들이 일어날 수 있기 때문에 공유자원에 접근하는 것을 보호해주는 영역을 뜻함   

 # Deadlock, 교착상태 
 일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태를 말합니다. 
 - 여기서 자원은 하드웨어, 소프트웨어적을 다 포함합니다. I/O, 메모리공간, semaphore 등
 - 프로세스가 자원을 사용하는 절차도 포함 ex) request, allocate 
 자원할당을 하는 그래프를 보았을 때 cycle이 있다면 deadlock이 될 수도 있고, 없다면 아니다. 
 자원을 할당할 때 데드락에 연루되지 않은 할당된 자원들이 있다면 할당가능성을 보고 데드락이 아니라고 할 수 있다. 
 ## 해결방법
 1. 자원할당을 할 때 애초에 조건이 성립을 안하게 설계하는 것입니다. 
 2. 데드락 가능성이 없을 때만 자원할당 
  - 프로세스당 요청할 자원들의 최대치를 통해 자원할당가능 여부를 파악(banker's algorithm)
 3. 데드락 detection and recover
  - 사이클이 있는지를 확인[detection]
  - 모든 데드락관련 프로세스를 죽이거나 한개씩 데드락이 사라질 때까지 지워본다. [recover#1]
  - 데드락에 관련된, 비용을 최소화할 자원을 뺏어서 데드락을 없앤다.  [recover#2] 
 4. 무시(unix, window os 채택), 데드락은 매우 드물게 일어나기 때문에 데드락을 처리하는 비용이 더 크기때문입니다. 데드락이 발생되면 사용자가 작업종료를 합니다. 

 # 메모리 관리
 - 논리적 주소, 프로그램 상 올라가 있는 주소, 프로세스마다 독립적으로 가지는 주소 공간
 - 물리적 주소, 메모리에 실제 올라가 있는 위치
주소를 결정하는 것을 **주소바인딩**이라고 합니다. 

 ##주소바인딩
 Symbolic Address - 논리적 주소 - 물리적 주소 로 주소들을 연결시키는 것
  - 예를 들어 함수명으로 호출하면 컴퓨터에서는 논리적주소와 물리적주소로 연결합니다.  
 
 ## 가상메모리 
 프로세스들이 메모리 여유가 없이 지나치게 많은 요구를 할 경우 이를 방지하기 위해 가상메모리가 존재합니다. 
- OS에서 따로 설정을 하지 않아도 자동작동해서 적용된다.
- 당장 사용하지 않는 영역을 하드디스크로 옮긴 뒤, 필요할 때만 램에 데이터를 불러와 올리고 사용하지 않으면 하드디스크로 내림으로써 램을 효과적으로 관리한다. 이를 스와핑이라고 한다. 
- 메모리관리의 단순화, 각 프로세스마다 가상메모리의 동일한 주소 공간을 배정할 수 있으므로 메모리 관리가 단순해진다. 
- 메모리 용량 및 안정성 보장, 무한한 가상메모리 공간을 배정
- 물리적인 RAM의 허용치를 넘어설 경우 하드디스크 등 보조기억장치를 쓰는데 이는 RAM보다 매우 느리기 때문에 RAM을 초과하는 데이터를 다뤄서 보조기억장치를 끌어다 쓸 경우 시스템의 속도가 확연히 느려진다.  

## 물리적 메모리 할당 
메모리는 일반적으로 두가지로 나누어진다. 
 - OS 상주 영역, 낮은 주소 영역
 - 사용자 프로세스 영역, 높은 주소 영역 
여기서 사용자 프로세스 영역을 메모리 주소에 올릴 때 방법 나뉘는데 크게 연속할당, 불연속할당이 있습니다. 

### 연속할당 
1. 고정분할방식
분할의 크기를 미리 나눠서 할당합니다. 
2. 가변분할방식
프로그램이 실행될 때마다 차곡차곡 올려 놓는 방법입니다. size가 n이상인 hole(비어있는 메모리 공간)을 찾아 할당하는 것입니다.  
- best-fit : n 이상인 공간 중 가장 작은 것 부터 할당
- first-fit : n 이상인 공간을 찾으면 바로 할당
이 두가지의 방법이 속도, 공간 측면에서 좋습니다.(실험적인 결과) worts-fit으로 가장 큰 hole에 할당하는 방법이 있지만 좋지 않습니다. 
레지스터 2개를 이용해서 할당을 합니다. 
1. 현재의 할당할 수 있는 시작 메모리 위치 
2. 어느정도의 메모리만 할당가능한지를 알 수 있는 것 
이렇게 2개를 이용해서 할당합니다.[기본적인MMU방식]

### paging, 불연속할당 
현재의 컴퓨터가 쓰는 방법입니다. page별로 주소변환을 해야 하며 프로그램마다 페이지테이블을 가지고 있어야 합니다. 
논리적 메모리를 동일한 크기의 paging으로 나눠서 물리적 메모리에 어디있는가를 결정합니다. 
그렇게 해서 각각의 페이지들이 필요할 때 물리적으로 올라갈 수 있다. 
 1. 논리적메모리를 동일한 크기의 page로 자릅니다. 보통 4kb 
 2. 매칭되는 페이지 테이블을 통해 주소변환이 되고 물리적메모리에 매핑됩니다. 
- 페이지테이블은 메인 메모리에 위치합니다.그래서 프로그램에 대한 메모리에 접근하기 위해서 2번접근하게 됩니다. 
 1)페이지테이블 
 2)그 테이블을 통한 메모리 할당을 하게 됩니다. 그래서 속도향상을 위해 TLB가 사용됩니다. 
### TLB
TLB는 별도의 하드웨어이며 메인메모리와 CPU사이에 있는 메모리 주소변환모듈입니다. 
메인메모리에서 캐싱메모리를 통해 빠르게 접근이 가능한 것처럼 메모리를 빠르게 전환하도록 사용되는 캐싱계층입니다. 
페이지테이블에 가기전에 TLB에 그 메모리가 있는지를 파악해서 빠르게 전달합니다. 이 페이지 테이블은 각각의 프로세스마다 페이지테이블이 존재하기 때문에 context switch시 비우게 됩니다.  

### 이단계 페이지 테이블, Two-level Page table
페이지테이블을 4kb에 할당하면 공간낭비가 심하다. 총 100만개의 주소공간이 할당되는데 (32비트 기준 2^32B, 4GB의 주소공간을 가짐)
그러나 대부분의 프로그램은 4G의 주소공간 중 지극히 일부분만 사용되므로 page table 공간이 심하게 낭비됩니다. 
- page table을 page 로 구성, 바깥쪽 테이블은 다 만들어 지되 사용안되는 안쪽 테이블이 안만들어지고 null상태로 되어있다.
- 다단계 페이지테이블, Multi-level Page table도 있다. (윈도우 32비트 사용)
논리적인 주소는 p1 + p2 + d로 되어있다. 
 - p1 : outer page table - 10bit
 - p2 : page of page table - 10 bit
 - d : 그 안에서 몇번째를 나타내는 depth(page offset) - 12bit
몇번째 엔트리인지를 구분하는 숫자. 
안쪽 테이블은 4byte이므로 1k개를 집어 넣을 수 있다. 
바깥쪽 테이블은 4kbyte이기 때문이다. 
안쪽 테이블도 페이지화 되서 들어간다. 

page table의 엔트리마다 아래의 bit를 둔다. 
- protection bit, page에 대한 접근 권한(read / write / read-only)
코드는 read-only, 데이타들은 read, write 가능하게 설계 

### inverted page table
page 테이블은 너무나 크기 때문에
물리적 메모리 만큼 페이지테이블이 존재한다. 
페이지 프레임의 f번째 테이블을 검색
주소변환을 반대로
페이지 엔트리를 전부다 검색해야 
시스템 공간을 줄이기 위해

## Shared Page
read - only 로 하여 프로세스 간에 하나의 code만 메모리에 올립니다. 
동일한 논리적 메모리에 위치해야 한다. 코드가 동일하다면 

- valid / invalid bit, 프로세스 내용이 있느냐 없느냐. 

어떻게 2단계 페이지를 만드는데도 효율성이 높아지느냐. 바깥쪽 테이블만 만들고 안쪽테이블은 만들어지지 않는게 많기 때문에

### valid, invalid bit
사용되냐 안되냐를 위해서 사용되는 비트
valid : 실제로 올라와있는 것 
invalid : 사용되지 않거나 페이지에 대한 물리변환요청을 안할 경우

테이블 페이지 사이에 비트가 있다. 
프로그램 주소 공간만큼 페이지 테이블 엔트리는 생성된다. 
테이블이라는 자료구조 특성상 위에서 부터 접근해야 하기 때문에 대신에 


page는 이제 끝. 
### segmatation, 불연속할당
프로세스 주소공간은 의미단위로 쪼갬(동일한 크기가 아니라)

segment number, offset 
번호만큼 떨어진 위치로 가면 세그먼트 테이블, 물리적메모리, limit, 의미단위로 자르기 떄문에 길이는 다를 수 있다. 
 - limit(세그먼트의 길이 ), base(세그먼트 시작 위치)가 있어
이 세그먼트가 정확히 어디에서 시작되는지 바이트로 알려주어야 한다. 
중간중간에 hole들이 생긴다. 
의미단위로 쪼개기 때문에
각 세그먼트 별로 Protection bit 이 있다.  
길이가 다르므로 가변분할과 동일한 문제점 발생, 의미단위로 공유와 보안에 대해 효과적이다. 
code, data, stack 부분이 하나의 세그먼트로 정의됩니다. 
이 세그먼트의 엔트리는 사용하는 엔트리의 갯수만큼 만들어집니다. 
운영체제는 메모리할당에 대해서 관여하지 않고 하드웨어적으로만 작동된다. 
CPU가 논리주소를 주게 되면 세그먼트 번호, 그리고 얼마나 떨어져있는지를 파악해서 한다. 
합당한 메모리인지 > 그렇지 않을 경우 트랩을 발동시킨다. 
page는 allocation에 장점이 있다. 
테이블에 대한 메모리 낭비가 심한것은 page, 

### segment & paging
공유나 보안은 세그먼트로 의미단위로
물리적 메모리는 페이지로
세그먼트의 길이가 오프셋이 더 크다면 요청한 오프셋, 이내인 경우에만 요청이 가능

운영체제의 역할? 
주소변환에 있어서 없습니다. 다 하드웨어가 한다. MMU라는 하드웨어가 한다. 
어떤 프로세스가 메모리접근 할 때마다 OS가 개입을 한다면 말이 안된다. 운영체제가 끼어들어야 할 때는 IO장치를 접근할 때만 끼어든다. 



3일차
=====
# Virtual memory
전적으로 운영체제가 관리를 한다. 
Demanding Paging, 실제로 필요한 메모리만 올립니다. 요청이 있다면 올린다.  
 - 메모리 사용량 감소 > 더 빠른 응답시간

 - valid, invalid bit 사용 : 사용되지 않거나 페이지가 물리적페이지에 없는 경우 invalid이며 그렇지 않다면 valid이다. 
 엔트리에 적힌다. 

## page fault
요청한 메모리가 없다. CPU는 OS로 넘어가서 fault난 메모리를 올려야 한다. 
메모리가 꽉차있다. 그렇다면 빈 페이지를 얻어내야 한다. 
1. 잘못된 요청인가 확인
2. 빈페이지를 가져오거나 replace를 한다. 
3. 해당 페이지를 disk에서  memory로 읽어 온다.
4. 이 프로세스가 CPU를 잡고 다시 인스트럭션을 실행한다. 
수십만배 ~ 백만배 느리다 디스크는 메모리에 비해 
이게 많이 나면 느려진다. 대부분의 경우는 메모리로부터 직접 주소변환이 가능하지만 꽉차 있거나 그러면 page fault가 발생하게 된다. 
인스트럭션을 수행시 
p : page fault rate 평소에는 0.1에 가깝다. 
1 - p * 메모리 접근시간 + p(OS & HW page fault overhead, swap page, OS & HW restart overhead)

빈페이지가 없는 경우 replace를 해야 한다. 
이 때 os가 필요하다. 
이 때 replacement 가 발생된다. 

## MMU
메모리 관리 장치(Memory Management Unit, 줄여서 MMU)는 CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품이다. 가상 메모리 주소를 실제 메모리 주소로 변환하며, 메모리 보호, 캐시 관리, 버스 중재 등의 역할을 담당합니다. CPU가 MMU에게 주소할당요청을 통해 메모리가 할당
되게 됩니다. 
## 메모리 할당과정 
 1. 잘못된 참조요청인가 확인
 2. 빈 empty frame에 할당하고 아니라면 replace를 한다. 
 3. 해당 페이지를 disk에서 memory로 읽어와서 작업재게 

### 메모리 바꾸는 과정
page-fault를 최대한 줄이는 것으로 바꿔야 한다.
offline-algorithm, optimal 
가장 먼 미래에 참조되는 페이지를 쫓아낸다. 원래 있는 것 중에서 가장 먼 미래에 참조되는 페이지를 바꾼다. 
사용할 수 없지만 다른 알고리즘 성능 비교에 대한 upper bound를 제공합니다. 이것보다 더 나은 방법이라는 것은 있을 수 없습니다. 

FIFO
메모리에 먼저 들어온 것을 먼저 쫓아냅니다. 메모리프레임을 늘려줘도 page fault가 증가하는 문제점 발생

LRU, Least Recently Used : 가장 오래된 참조를 바꾼다. 최근에 참조된 것들이 다시 참조될 가능성이 높기 때문이다. 
 - Linked list로 구현 O(1) 참조될 때마다 가장 아래쪽으로 매달고 요청할 때마다 가장 윗부분을 바꾸면 됩니다. 
LFU,Least Frequently Used : 참조횟수가 제일 적은 것을 바꾼다.가장 적은 참조를 바꾼다. 참조횟수가 같다면 오래된 참조를 바꾸는 것이 좋다.
 - HEAP을 통해 O(logn) 구현 업데이트에 logn, 바꿀 때는 O(1)

## 다양한 캐싱환경

한정된 빠른 공간에 데이터를 저장해놓고 같은 데이타를 요청했을 때 바로 서비스를 할 경우 빠르다는 것.
페이징시스템에서 사용가능한가. 
주소변환을 했는데 invalid, page fault가 발생 > 디스크에서 가져와야 한다. 
운영체제가 디스크에 있는 (io작업)
어떤 것을 쫓아낼지..? 
메모리에 그 페이지가 없으면 운영체제가 참조횟수 등을 쓸 수 있지만 그렇지 않다면 불가능 하다. 
그래서 불가능하다. 운영체제에 반쪽만 전달되기 때문에
그래서 clock 알고리즘이 사용된다.

### clock 알고리즘
LRU의 근사 알고리즘으로 불린다. 
최근에 사용되지 않은 프로세스를 쫓아 낸다. 
reference bit을 1로 설정, 최근에 참조되었다를 의미
시계방향을 돌면서 0을 찾아서 바꾼다. 
운영체제는 circular linked list
적어도 시계방향을 돌면서 사용되지 않는 것. 0을 찾음 지나가면서 reference bit이 1인것은 0으로 바꿈

modified bit : 최근에 변경된 페이지

# COW

# page frame의 allocation
어떤 프로그램이 원할하게 실행이 되려면 일련의 프로세스들이 같이 올라와 있어야 한다. 
모든 프로그램에 똑같은 갯수를 할당
프로그램 크기에 비례 할당
프로세스 우선순위에 따라 다르게 할당

## Thrashing
page fault가 많이 일어나는 상황
프로세스에게 너무 적은 page를 할당받은 경우 발생
메모리에 너무 많은 프로세스가 동시에 올라가게 되면
동시에 올라가는 메모리 갯수를 조절해줘야 한다. 이를 위한 알고리즘은 다음과 같다. 
working-set
reference of locality
프로세스는 특정시간 동안 일정페이지만 집중적으로 참조함, 이를 locality set이라 한다. 
이를 기반으로 한꺼번에 올라와있어야 하는 페이지들의 집합을 working set이라고 합니다. 
과거를 통해 working-set을 참조

page fault frequency algorithm
page fault rate에 따라서 페이지 갯수를 조절한다. 
상한값과 하한값으로 조절하여 

## 파일
관련정보를 이름을 가지고 저장하는 것. 
다양한 저장장치를 file 이라는 논리적 단위로 볼 수 있게 해준다. 
file attribute , 메타데이터
파일을 관리하기 위한 각종 정보들
file system
운영체제에서 파일을 관리하는 부분
파일 및 파일의 메타데이타 등을 관리 
open , read 인터페이스
open, close : 
open: 이 파일의 메타데이타를 메모리에 올려놓는다를 open이라고 한다. 
close : 

